#! /bin/bash
#
# script name: VMMgr_Launcher
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: VMMgr_Launcher allow start/stop/create/destroy Virtual Machines
#
# ToDo: on doit vérifier si un bridge n'a plus de slave, on le delete.
# Quid d'iptables
# Gestion des migrations?
# delete doit avoir l'option --data pour delete les disques
# Table pour gérer les disques et les déplacer?
# fonction connect pour lancer spice,qmp et telnet.
#
# Versionning:
# Les version 0.xx sont pour les branches d'ajoute de fonctionnalité post 2.0
# Les version 1.xx sont les releases dont on a ajouté une fonctionnalité validée
# La Version 2.0 sera une version pleinement fonctionnelle
#
# STEP:
# 0.06 on doit valider la fonction start: c'est à dire
# 0.07 on doit valider une première VM fonctionnelle, on doit donc reparcourir toutes les options de base pour créer vrai VM.
# 1. on doit valider que la vm existe dans la DB, pas d'initialisation de DB
# 2. valider que la config existe, pas de création
# 3. Créer les disques nécessaire, valider l'espace disque restant avant
# 4. Démarrer la VM
#
# 0.07 On doit valider la fonction check: vérifier l'installation des paquets avec rpm. Si rpm n'existe pas, afficher simplement la liste des programmes à installer.
#
# 0.08 on doit valider la fonction de création manuelle de disques
#
# 0.09 fonction stop
# 0.10 fontion delete
# 0.11 fonction status/kill/reset
# 0.12 funtion ipmi
# 0.13 Spice/telnet/qmp
# 0.14 vnc
# 0.15 templates linux + Windows
# 0.16 les units systemd (pour la vm, pour ipmi etc.)
# 0.17 Gestion des groupes

# on charge les variables et paths nécessaire à l'exécution du script
if [ -r /usr/local/etc/VMMgr_.conf ]; then
 . /usr/local/etc/VMMgr_.conf
elif [ -r $(dirname $0)/VMMgr_.conf ]; then
 . $(dirname $0)/VMMgr_.conf
else
 echo "No config VMMgr_.conf found, abording..."
 return
fi

# Loading Libs
. $VMMGR_DATA_PATH/VMMgr_Libs/VMMgr_Db
. $VMMGR_DATA_PATH/VMMgr_Libs/VMMgr_Functions
. $VMMGR_DATA_PATH/VMMgr_Libs/VMMgr_Networks
. $VMMGR_DATA_PATH/VMMgr_Libs/VMMgr_Disks
. $VMMGR_DATA_PATH/VMMgr_Libs/VMMgr_CPUs
Check_System

case "$1" in
    "check")
        # on doit vérifier que tous les outils sont installés et au bon endroit, sinon prévenir
        ;;
    "create")
            # Args:
            #   $2: Vm Name
            #   $3: Template Name
            # Steps:
            #   1) Check Vars, template, if vm and config file already exists
            #   2) Declare VM in DB, copy template, and customize Vars
            if [ ! "$2" ] || [ ! "$3" ]; then
                echo "Usage $0 <vm name> <template>"
            else if [ ! -r $VMMGR_DATA_PATH/Templates/$3 ]; then
                echo "Error, template $VMMGR_DATA_PATH/Templates/$3 doesn't exists"
                 else
                    VMCONF=$(Check_Existing_VM $2)
                    if [ "$VMCONF" == "" ]; then VMCONF="$2.conf"; fi
                    if [ -r $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF ]; then 
                        echo "Warning, config file $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF already exists"
                    else
                        cp $VMMGR_DATA_PATH/Templates/$3 $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                        Custom_VM_Config $2 $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                    fi
                    VMID=$(Db_Create_VM $VMMGR_DB_PATH $2 $VMCONF)
                fi
            fi
        ;;
    "delete")
            # Args:
            #   $2: Vm Name
            #   $3: 'config' <optional>
            # Steps:
            #   1) Check if VM exists in DB
            #   2) Delete from DB
            #   3) Check $3 to know optional delete: config-file and/or disks
            # TODO: systemd files, besoin de disable avant????
            if [ ! "$2" ]; then
                echo "Usage $0 delete <vm name> [config|disks|conf-disks]"
            else
                VMCONF=$(Check_Existing_VM $2)
                if [ "$VMCONF" == "" ]; then
                    echo "VM $2 not found in DB"
                else
                    Db_Delete_VM $VMMGR_DB_PATH $2
                    if [ -r $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF ] && [ "$3" == "config" ]; then
                        rm $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                    fi
                fi
            fi
        ;;
    "start")
        # Args:
        #   $2: Vm Name
        # Steps:
        #   1) Check if VM exists in DB
        #   2) Check if enabled
        #   3) if enabled, use systemctl to start vm
        #   4) if disabled or systemctl return no unit, start manually
            if [ ! "$2" ]; then
                echo "Usage $0 start <vm name>"
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            echo "use config: $USEQEMUCONFIG"
            elif [ -r "$VMMGR_CONFIG_PATH/QEMU_CONFIGS/$2" ] && [ ! "$3" == "regen" ] && [ "$USEQEMUCONFIG" != "no" ]; then
                qemu-system-x86_64 -daemonize -readconfig $VMMGR_CONFIG_PATH/QEMU_CONFIGS/$2
            else
                VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
                if [ "$VMCONF" == "" ]; then
                    echo "$2 not found in DB"
                else
                    SYSD=$(Db_isEnabled_VM $VMMGR_DB_PATH $2)
                    if [ "$SYSD" == "1" ]; then
                        SYSDSTATUS=$(systemctl status "VM_$2.service" 2>&1>/dev/null)
                        case "$SYSDSTATUS" in
                            "0")
                                echo "$2 already running!"
                            ;;
                            "1")
                                echo "Unknown error"
                            ;;
                            "2")
                                echo "Unknown error"
                            ;;
                            "3")
                                systemctl start "VM_$2.service" 2>&1>/dev/null
                            ;;
                            "4")
                                Start_VM_From_Config $2 $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                            ;;
                        esac
                    else
                        if [ ! -r $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF ]; then
                            echo "VM $2 not found"
                        else
                            Start_VM_From_Config $2 $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                        fi
                    fi
                fi
            fi
        ;;
    "enable")
        ;;
    "stop")
        VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            if [ "$TELNET" == "on" ]; then
                IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                { echo "system_powerdown"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            elif [ "$QMP" == "on" ]; then
                IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                { echo  { echo '{ "execute": "qmp_capabilities" } { "execute": "system_powerdown" } { "execute": "quit" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            fi
        fi
        ;;
    "group")
        ;;
    "status")
         VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            if [ "$TELNET" == "on" ]; then
                IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                { echo "info status"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            elif [ "$QMP" == "on" ]; then
                IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                { echo '{ "execute": "qmp_capabilities" } { "execute": "query-status" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            fi
        fi
        ;;
    "kill")
        VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            if [ "$TELNET" == "on" ]; then
                IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                { echo "quit"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            elif [ "$QMP" == "on" ]; then
                IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                { echo  { echo '{ "execute": "qmp_capabilities" } { "execute": "quit" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            fi
        fi
        ;;
    "reset")
        VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            if [ "$TELNET" == "on" ]; then
                IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                { echo "system_reset"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            elif [ "$QMP" == "on" ]; then
                IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                { echo  { echo '{ "execute": "qmp_capabilities" } { "execute": "system_reset" } { "execute": "quit" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
            fi
        fi
        ;;
    "ipmistart")
        ;;
    "ipmistop")
        ;;
    "ipmistatus")
        ;;
    "define")
        ;;
    "connect")
        VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
            case "$3" in
                "spice")
                        nohup remote-viewer $VMMGR_CONFIG_PATH/R-SPICE/$2 &
                ;;
                "telnet")
                    IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                    telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                ;;
                "qmp")
                    IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                    telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                ;;
                "vnc")
                    nohup remote-viewer $VMMGR_CONFIG_PATH/R-VNC/$2 &
                ;;
            esac
        fi
        ;;
    "load")
        VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
        if [ "$VMCONF" == "" ]; then
            echo "$2 not found in DB"
        else
            if [ "$3" ]; then
                case "$3" in
                    "virtiowin")
                        ISO=$VMMGR_ISO_PATH/virtio-win.iso
                    ;;
                    *)
                        if [ -f "$3" ]; then
                            ISO=$3
                        elif [ -f "$VMMGR_ISO_PATH/$3" ]; then
                            ISO="$VMMGR_ISO_PATH/$3"
                        fi
                    ;;
                esac
                . $VMMGR_CONFIG_PATH/VM_CONFIGS/$VMCONF
                if [ "$TELNET" == "on" ]; then
                    IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
                    { echo "change DVD $ISO"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                    if [ "$4" == "reset" ]; then
                        { echo "system_reset"; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                    fi
                elif [ "$QMP" == "on" ]; then
                    IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
                    { echo '{ "execute": "qmp_capabilities" } { "execute": "change DVD $ISO" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                    if [ "$4" == "reset" ]; then
                        { echo  { echo '{ "execute": "qmp_capabilities" } { "execute": "system_reset" } { "execute": "quit" }'; sleep 1; } | telnet $(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}') ${IPPORT#*|}
                    fi
                fi
            fi
        fi
        ;;
     "wintools")
        ### Virtio Win
        wget https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso --directory-prefix=$VMMGR_ISO_PATH/
        ### QEMU Guest Agent
        wget https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-qemu-ga/qemu-ga-win-100.0.0.0-3.el7ev/qemu-ga-x64.msi --directory-prefix=$VMMGR_ISO_PATH/
        ### Spice Guest Tools
        wget https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe --directory-prefix=$VMMGR_ISO_PATH/
        ;;
    *)
        ;;
esac
