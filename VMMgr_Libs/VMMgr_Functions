#! /bin/bash
#
# script name: VMMgr_Functions
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: All usefull functions
#
# Functions:
# Check_Softwares: try to check if all required software are installed
# Check_System: Check system requirements
# Set_Bridge_Brctl: Set bridges using brctl
# Set_Bridge_Ovs: Create bridge using openvswitch
# Set_Bridge_Nmcli: create bridge using nmcli
# Check_MEM: Check if MEM and MAXMEM, if MAXMEM is undefined, calculate MEM * 2
# Set_NetDev: Create tap interfaces
# Set_MAC: Calculate MAC Address
# Set_IPMI: Create IPMI device, using OpenIPMI-lanserv 
# Custom_VM_Config: Customize VM Configuration
#
# Set_New_Port: Get Port or generate new one
# Get_Next_IPv4: Generate new IP from a pool
# Get_Next_IPv6: Generate new IP from a pool
# Set_New_IP: Get IP or generate new one
# Create_Tap: Create Tap iface
# Create_Bridge: create bridge dispatcher
# Enslave_Tap: enslave Tap to a bridge
# Set_Iface_Net: Add IP to an iface
#
# Get_Bridge_Tool: Try to detect best bridge tool available


## TODO:
## Créer des units systemd
## créer les fichiers spice
## créer un tableau de numa
# créer un tableau de périphériques disque



# Function Check_Softwares
# Description: try to check if all required software are installed
# Args: no args
function Check_Softwares() {
    qemu-system_x86_64
    openIPMI_lanserv
    sqlite3
}

# Function: Check_System
# Description: Check system requirements
# Args: no args
# Steps:
#   1: Check module vhost-net
#   2: Check perms on /dev/net/tun, /dev/vhost-net and /dev/kvm
#   3: Set cap_net_admin on qemu-system_x86_64
function Check_System() {
    if [ "$(sudo modinfo vhost-net -F intree)" != "Y" ]; then
        sudo modprobe vhost vhost-net
    fi
    
    ls -l /dev/net/tun | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/net/tun
    fi

    ls -l /dev/vhost-net | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/vhost-net
    fi

    ls -l /dev/kvm | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/kvm
    fi

    sudo getcap /usr/bin/qemu-system-x86_64 | grep cap_net_admin+ep > /dev/null
    if [ $? -ne 0 ]; then
        sudo setcap cap_net_admin+ep /usr/bin/qemu-system-x86_64
    fi
    
    # On a besoin de voir comment faire dans sudo pour que ça fonctionne
    #if [ $(cat /proc/sys/net/ipv4/ip_forward) -eq 0 ]; then
        #sudo echo 1 > /proc/sys/net/ipv4/ip_forward
    #fi
    
    modinfo openvswitch 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        sudo modprobe openvswitch
        [ -d /var/run/openvswitch ] || sudo mkdir /var/run/openvswitch
    fi
}

# Function: Set_Bridge_Brctl
# Description: Set bridges using brctl
# Args:
#     $1: bridge name
function Set_Bridge_Brctl() {
    ip address show $1 2> /dev/null 1> /dev/null
    if [ $? -ne 0 ]; then
        sudo ip link add $1 type bridge
        sudo ip link set dev $1 up
    fi
}

# function: Set_Bridge_Ovs
# Description: Create bridge using openvswitch
# Args:
#    $1: Bridge name
function Set_Bridge_Ovs() {
 if [ "$(sudo ovs-vsctl list-br | grep $1)" == "" ]; then
  sudo ovs-vsctl add-br $1
  sleep 0.1
  sudo ip link set dev $1 up
 fi
}

# function: Set_Bridge_Nmcli
# Description: create bridge using nmcli
# Args:
#    $1: Bridge name
function Set_Bridge_Nmcli() {
  nmcli dev show $1 2>/dev/null 1>/dev/null
 if [ $? -ne 0 ]; then
  sudo nmcli con add save yes type bridge ifname $1
  sudo nmcli con mod bridge-$1 connection.id $1
  #sudo nmcli dev set $1 autoconnect yes managed yes 
  sudo nmcli con mod $1 ipv4.method disabled
  sudo nmcli con mod $1 ipv6.method ignore
  sudo nmcli con up $1
  #sudo nmcli dev connect $1
  #sudo nmcli dev reapply $1
 fi
}

# Function Check_MEM
# Description: Check if MEM and MAXMEM
# if MAXMEM is undefined, calculate MEM * 2
# Args:
#   $1: $MEM
#   $2: $MAXMEM
function Check_MEM() {
 if [ "$1" ]; then
  if [ "$2" ]; then
   echo $2
  else
   MAXMEM=$(( $1 * 2 ))
   MAXSYS=$(( $(grep "MemTotal: " /proc/meminfo  | awk '{print $2}' ) / 1024 / 1024 ))
   if [ $MAXMEM -gt $MAXSYS ]; then $MAXMEM == $MAXSYS; fi
   echo $MAXMEM
  fi
 else
   return 0
 fi
}

# Function: Set_NetDev
# Description: Create tap interfaces
# Args:
#   $1: Bridge name
#   $2: Number of tap devices
#   $3: tapupdown file path
# Return an array of netdev declarations
function Set_NedDev() {
    for NETNUMBER in $(seq $(( ${#NETDEV[@]} + 1 )) $(( ${#NETDEV[@]} + $2 )) ); do
        NETDEV[$NETNUMBER]="-netdev type=tap,id=virtio-tap$NETNUMBER,script=$3/tapup-$1,downscript=$3/tapdown-$1,vhost=on -device virtio-net-pci,netdev=virtio-tap$NETNUMBER,mac=$(Set_MAC $NETNUMBER),id=drive-virtio-tap$NETNUMBER,csum=off,gso=off,guest_tso4=off,guest_tso6=off,guest_ecn=off"
    done
}

# Function: Set_MAC
# Description: Calculate MAC Address
# Args:
#   $1: Vm Name
#   $2: network device number
function Set_MAC() {
        OUI="52:54:00"
        SUBMAC=Db_Set_MAC $DB_PATH $1 $2
        echo $OUI:${SUBMAC:0:2}:${SUBMAC:2:2}:${SUBMAC:4:2}
}

# Function: Set_IPMI
# Description: Create IPMI device, using OpenIPMI-lanserv 
# Args:
#   $1: Vm Name
#   $2: IPMI Template Path
#   $3: IPMI Address
#   $4: IPMI Port
function Set_IPMI() {
  if [ ! -f /etc/ipmi/$2.conf ]; then
    cp $2 /etc/ipmi/$1.conf
    sed -i "s/%%IPMIADDR%%/$3/" /etc/ipmi/$1.conf
    sed -i "s/%%IPMIPORT%%/$4/" /etc/ipmi/$1.conf
    sed -i "s/%%NAME%%/$1/g" /etc/ipmi/$1.conf
  fi
}

# Function : Check_Existing_VM
# Description: Check on DB if VM already exists
# Args:
#   $1: VM Name
function Check_Existing_VM() {
 Set_Db $VMMGR_DB_PATH
 Db_Get_VM_Config $VMMGR_DB_PATH $1
}

# Function: Custom_VM_Config
# Description: Customize VM Configuration
# Args:
#   $1: VM name
#   $2: VM config path
function Custom_VM_Config() {
    sed -i "s/%%NAME%%/$1/g" $2
}

# Function: Start_VM_From_Config
# Description: Start VM using VM Config file
# Args:
#   $1: VM Name
#   $2: VM config path
function Start_VM_From_Config() {
    source $2
    qemu-system-x86_64 $QEMU_TEMPLATE
    
    # enregistrer SPICE, TELNET, QMP, VNC
}

# Function: Set_Service_Listen
# Description: Set IP and Port for Spice
# Args:
#   $1: IP or Iface name
#   $2: $IPVER
#   $3: Iface type
# Steps:
#   1) is $1 an IP?
#   2)  yes: is IP already exist? yes -> return $1; no create iface and set ip 
#   3)  no: is existing iface? yes -> return first IP; no; create iface and set IP
function Set_Service_Listen() {
    # Première chose: on récupère l'ip:port depuis la db.
    # Ensuite si on a rien, on vérifie
    ipcalc -$2 $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        echo "IP valide"
        ip -$2 -br address show | grep $1 2>/dev/null 1>/dev/null
        if [ $? -eq 0 ]; then
            echo $1
        else
            echo "ip inexistante"

        fi
    else
        echo "Not an IP"
        case "$3" in
                "tap")
                    IFACE=$(ip -br address show type tun | grep $1 | head -1 | awk '{print $1}')
                    if [ "$IFACE" == "" ]; then
                        echo "not tun"
                    else
                        echo "yes tun $IFACE"
                    fi
                ;;
                "bridge")
                    IFACE=$(ip -br address show type bridge | grep $1 | head -1 | awk '{print $1}')
                    if [ "$IFACE" == "" ]; then
                        echo "not bridge"
                    else
                        echo "yes bridge: $IFACE"
                    fi
                ;;
                "tap2br")
                    echo "tap2br"
                    IFACE=$(ip -br address show type tun | grep $1 | head -1 | awk '{print $1}')
                    if [ "$IFACE" == "" ]; then
                        echo "not tun"
                    else
                        echo "yes tun $IFACE"
                    fi
                ;;
        esac
    fi
}            

function Is_Valid_IP() {
    NET="-4"
    [ "$IPMODE" == "ipv6" ] && NET="-6"
    ipcalc $NET $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

function Is_Existing_IP() {
    NET="-4"
    [ "$IPMODE" == "ipv6" ] && NET="-6"
    ip $NET -br address show | grep $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

function Is_Existing_Bridge() {
    ip -br address show type bridge $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

# Function: Set_New_Port
# Description: Get Port or generate new one
#   $1: Vm Name
#   $2: Type [spice|telnet|qmp|vnc]
#   $3: min port
#   $4: max port
function Set_New_Port() {
    EXISTS=$(Db_Get_IPPORT $VMMGR_DB_PATH $1 $2)
    if ["$EXISTS" == "" ]; then
        for PORT in $(seq $3 $4); do
            EXISTS=$(Db_Search_Port $VMMGR_DB_PATH $1 $PORT)
            if [ "$EXISTS" != "" ]; then break; fi
        done
    fi
    echo $EXISTS | cut -d\|  -f2
}


# Function: Get_Next_IPv4
# Description: Generate new IP from a pool
# Args:
#   $1: Network
# Steps:
#   1) extract Network values
#   2) get IP, convert in Hex value for operations
#   3) Calculate next IP
#   4) Check if we are not out of pool
function Get_Next_IPv4() {
    IFS=\| read -r IPNETWORK IPPREFIX MIN MAX LAST BR <<< $(echo "$1")

    IFS=. read -r i1 i2 i3 i4 <<< $(ipcalc --network $IPNETWORK --prefix $IPPREFIX --info | grep Network | awk '{print $2}' | cut -d\/ -f 1)
    printf -v Network '%02x' $i1 $i2 $i3 $i4
    
    printf -v LAST '%02x' $LAST
    FirstIP=$(echo "obase=16;ibase=16; ${Network^^} + ${LAST^^}" | bc)
    NextIP=$(echo "obase=16;ibase=16; ${FirstIP^^} + 1" | bc)
    printf -v NextIP '%08x' 0x$NextIP
    NextIP=${NextIP^^}
    
    printf -v MAX '%02x' $MAX
    MaxIP=$(echo "obase=16;ibase=16;${Network^^} + ${MAX^^}" | bc)
    printf -v MaxIP '%08x' 0x$MaxIP
    MaxIP=${MaxIP^^}
    
 
    if [ $(echo "obase=10;ibase=16; ${NextIP^^}" | bc) -le $(echo "obase=10;ibase=16; ${MaxIP^^}" | bc) ]; then
        echo $(echo "ibase=16;obase=A;${NextIP:0:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:2:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:4:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:6:2}" | bc)
    fi
}

# Function: Get_Next_IPv6
# Description: Generate new IP from a pool
# Args:
#   $1: Network
# Steps:
#   1) extract Network values
#   2) get full lengh IPv6
#   3) Calculate next IP
#   4) Check if we are not out of pool (I know, useless...)
function Get_Next_IPv6() {

    IFS=\| read -r IPNETWORK IPPREFIX MIN MAX LAST BR <<< $(echo "$1")
    
    Network=$(ipcalc -6 --network $IPNETWORK/$IPPREFIX  --info | grep "Full Network" | awk '{print $3}' | cut -d/  -f1 | tr -d : )
    FirstIP=$(echo "obase=16;ibase=16; ${Network^^} + ${LAST^^}" | bc)
    NextIP=$(echo "obase=16;ibase=16; ${FirstIP^^} + 1" | bc)

    MaxIP=$(echo "obase=16;ibase=16;${Network^^} + ${MAX^^}" | bc)
    if [ "$(echo "obase=16;ibase=16; ${MaxIP^^} > ${NextIP^^}" | bc)" == "1" ]; then
        echo ${NextIP:0:4}:${NextIP:4:4}:${NextIP:8:4}:${NextIP:12:4}:${NextIP:16:4}:${NextIP:20:4}:${NextIP:24:4}:${NextIP:28:4}
    fi
}

# Function: Set_New_IP
# Description: Get IP or generate new one
#   $1: Vm Name
#   $2: Type [spice|telnet|qmp|vnc]
#   $3: Network
#   $4: IPVER
function Set_New_IP() {
    EXISTS=$(Db_Get_IPPORT $VMMGR_DB_PATH $1 $2)
    if ["$EXISTS" == "" ]; then
        EXISTS=$(Db_Get_Network $VMMGR_DB_PATH $3)
        if [ "$EXISTS" != "" ]; then
            [ "${4^^}" == "IPV4" ] && EXISTS=$(Get_Next_IPv4 $EXISTS)
            [ "${4^^}" == "IPV6" ] && EXISTS=$(Get_Next_IPv6 $EXISTS)
        fi
    fi
    echo $EXISTS | cut -d\|  -f1
}

# Function: Create_Tap
# Description: Create Tap iface
# Args:
#   $1: tap name
function Create_Tap() {
    sudo ip tuntap add mode tap $1
    sudo ip link set dev $1 up
}

# Function: Create_Bridge
# Description: create bridge dispatcher
# $1: Bridge Name
# $2: Bridge Tool
function Create_Bridge() {
        case "$2" in
            "brctl")
                Set_Bridge_Brctl $1
            ;;
            "ovs")
                Set_Bridge_Ovs $1
            ;;
            "nmcli")
                Set_Bridge_Nmcli $1
            ;;
        esac
}

# Function: Enslave_Tap
# Description: enslave Tap to a bridge
# Args:
# $1: tap name
# $2: Bridge Name
# $3: Bridge Tool
function Enslave_Tap() {
        case "$3" in
            "brctl")
                sudo brctl addif $2 $1
            ;;
            "ovs")
                sudo ovs-vsctl add-port $2 $1
            ;;
            "nmcli")
                sudo nmcli con add type bridge-slave ifname $1 master $2
            ;;
        esac
}

# Function: Set_Iface_Net
# Description: Set IP/Prefix to net device
# Args:
#   $1: IP
#   $2: Port
#   $3: Iface
function Set_Iface_Net() {
    sudo ip address add $1/$2 dev $3
}

# Function: 
# Description: Create New Network
# Args:
#   $1: Iface Name
#   $2: Network IP
#   $3: Prefix
#   $4: First IP available -1
#   $5: Last IP available
#   $6: Type (bridge or tap)
function Create_New_Network() {
    Db_Create_Network $VMMGR_DB_PATH $2 $3 $4 $5 $1
}

# Function: New_Network
# Description: create bridge or tap device
# Args:
#   $1: Device Name
#   $2: Device type: tap or bridge
#   $3: <ipversion>|<IP>|<prefix>
#   $4: (optional) bridge name for tap device only, tap will added to this bridge
function New_Network() {
    IFS=\| read -r IPVER IPNETWORK IPPREFIX <<< $(echo "$3")
    if [ "$2" == "bridge" ]; then
        ip -br address show type bridge $1 2>/dev/null 1>/dev/null
        if [ $? -eq 0 ]; then
            if [ "$3" != "" ]; then
                ip -br address show $1 | grep $IPNETWORK 2>/dev/null 1>/dev/null
                if [ $? -eq 1 ]; then
                    Set_Iface_Net $IPNETWORK $IPPREFIX $1
                fi
            fi
        else
            Create_Bridge $1 $BRIDGETOOL
            if [  "$3" != "" ]; then
                [ "$IPVER" == "4" ] && 
                Set_Iface_Net $IPNETWORK $IPPREFIX $1
            fi
        fi
    else
        if [ "$2" == "tap" ]; then
            ip -br address show type tun $1 2>/dev/null 1>/dev/null
            if [ $? -ne 0 ]; then
                sudo ip tuntap add mode tap $1
                sudo ip link set dev $1 up
            fi
            ip -br address show $1 | grep $IPNETWORK 2>/dev/null 1>/dev/null
            if [ $? -ne 0 ]; then
                Set_Iface_Net $IPNETWORK $IPPREFIX $1
            fi
            if [ "$4" != "" ]; then
                Enslave_Tap $1 $4 $BRIDGETOOL
            fi
        fi
    fi
}

# Function Get_Bridge_Tool
# Description: Try to detect best bridge tool available
# Args: No Args
function Get_Bridge_Tool() {
    ip --version 2>/dev/null 1>/dev/null
    [ $? -eq 0 ] && BRIDGETOOL="ip"
    ovs-vsctl --version 2>/dev/null 1>/dev/null
    [ $? -eq 0 ] && BRIDGETOOL="ovs"
    nmcli --version 2>/dev/null 1>/dev/null
    [ $? -eq 0 ] && BRIDGETOOL="nmcli"
    export BRIDGETOOL
}
