#! /bin/bash
#
# script name: VMMgr_Functions
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: All usefull functions
#
# Functions:
# Check_Softwares: try to check if all required software are installed
# Check_System: Check system requirements
# Check_MEM: calculate and/or check MEM and MAXMEM
# Set_UEFI: Create UEFI firmware
# Set_IPMI: Create IPMI device, using OpenIPMI-lanserv 
# Custom_VM_Config: Customize VM Configuration
# Set_Remote_Viewer: Create .vv file for remove viewer
# Start_VM_From_Config: Start VM using VM Config file
# Install_VMMGR: Install VMMGR on the system
# Uninstall_VMMGR: Remove VMMGR from the system
# VM_Is_Running: check if vm is running
# List_All_VM: Get the list of VMs

# Function Check_Softwares
# Description: try to check if all packaged are installed or not
# Args:
#   $1: Software List
#   $2: (bool) Not Installed=0, Installed=1 
function Check_Softwares() {
    TOBEINSTALL=""
    PACKAGENEEDED=$(echo $1 | tr \|  \   )
    for PACKAGE in $(echo $PACKAGENEEDED); do
        if [ "$(rpm -qa $PACKAGE)" == "" ]; then
            TOBEINSTALL="$TOBEINSTALL $PACKAGE"
        else
            INSTALLED="$PACKAGE"
        fi
    done
    if [ $2 -eq 0 ]; then
        echo $TOBEINSTALL
    else
        echo $INSTALLED
    fi
}

# Function: Check_Requirements
# Description: Helper for hypervisor configuration
# Args: no
function Check_Requirements() {
    echo "Checking..."
    echo ""
    PACKAGES=$(Check_Softwares "qemu-system-x86|sqlite edk2-ovmf|virt-viewer" 0)
    if [ "$PACKAGES" ]; then
        echo "You must install the following packages: $PACKAGES"
        echo ""
    fi
    PACKAGES=$(Check_Softwares "NetworkManager|openvswitch|virglrenderer|dpdk" 0)
    if [ "$PACKAGES" ]; then
        echo "You can install the following optionals packages: $PACKAGES"
        echo ""
    fi
    PACKAGES=$(Check_Softwares "ulatencyd" 1)
    if [ "$PACKAGES" ]; then
        echo "You should delete following packages: $PACKAGES"
        echo ""
    fi
    
    if [ "$(getent group qemu)" == "" ]; then
        echo "You must create group 'qemu'"
        echo "kvm user must in this group too"
        echo ""
    fi
    
    echo "Sudoers: You must set the following rules:"
    echo "Cmnd_Alias VMMGRCMD= /usr/sbin/ip, /usr/sbin/brctl, /usr/bin/ovs-vsctl, /usr/bin/nmcli, /usr/sbin/setcap, /usr/bin/systemctl"
    echo "%qemu ALL=(root:root) NOPASSWD: VMMGRCMD"
    echo ""
    
    ISOPATH=$(sudo -u qemu ls -l $VMMGR_ISO_PATH 2>/dev/null)
    if [ "$ISOPATH" == "" ]; then
        echo "If you plan to use systemd, you ISO PATH ($VMMGR_ISO_PATH) must be readable by qemu user"
        echo ""
    fi
    
    echo "DISKPATH: if you plan to use systemd, your DISKPATH var in your VM configs must be readable by qemu user"
    echo ""
    
    for KERNELOPT in $(echo "nodelayacct transparent_hugepage=madvise elevator=deadline kvm-intel.nested=1 iommu=1 intel_iommu=on kvm-intel.ept=1"); do
        if [ "$(cat /proc/cmdline | grep $KERNELOPT)" == "" ]; then
            OPTIONS="$OPTIONS $KERNELOPT"
        fi
    done
    if [ "$OPTIONS" ]; then
        echo "You should add the following kernel options in your grub.cfg:"
        echo $OPTIONS
        echo ""
    fi

    if [ "$(tuned-adm list | grep hypervisor)" == "" ]; then
        echo "You should install tuned profile provided by copying Configs/tuned.conf in /etc/tuned/hypervisor/"
        echo ""
    fi
    
    if [ "$(tuned-adm active | grep hypervisor)" == "" ]; then
        echo "tuned profile hypervisor is not active!"
        echo ""
    fi
    
    echo "SPICE/VNC secure mode: make sure keys and certificates are readable by qemu user and/or group"
}

# Function: Check_System
# Description: Check system requirements
# Args: no args
# Steps:
#   1: Check module vhost-net
#   2: Check perms on /dev/net/tun, /dev/vhost-net and /dev/kvm
#   3: Set cap_net_admin on qemu-system_x86_64
function Check_System() {
    if [ "$(modinfo vhost-net -F intree)" != "Y" ]; then
        sudo modprobe vhost vhost-net
    fi
    
    ls -l /dev/net/tun | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/net/tun
    fi

    ls -l /dev/vhost-net | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/vhost-net
    fi

    ls -l /dev/kvm | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/kvm
    fi

    getcap /usr/bin/qemu-system-x86_64 | grep cap_net_admin+ep > /dev/null
    if [ $? -ne 0 ]; then
        sudo setcap cap_net_admin+ep /usr/bin/qemu-system-x86_64
    fi
    
    # On a besoin de voir comment faire dans sudo pour que Ã§a fonctionne
    #if [ $(cat /proc/sys/net/ipv4/ip_forward) -eq 0 ]; then
        #sudo echo 1 > /proc/sys/net/ipv4/ip_forward
    #fi
    
    modinfo openvswitch 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        sudo modprobe openvswitch
        [ -d /run/openvswitch ] || sudo mkdir /run/openvswitch
    fi
    
    if [ ! -r "/run/VMMGR" ]; then
        sudo mkdir /run/VMMGR 
        sudo chown -R qemu:qemu /run/VMMGR
        sudo chmod -R 770 /run/VMMGR
    fi
}


# Function Check_MEM
# Description: Check if MEM and MAXMEM
# if MAXMEM is undefined, calculate MEM * 2
# Args:
#   $1: $MEM
#   $2: $MAXMEM
#   $3: Max Slots (optional)
function Check_MEM() {
 [ "$1" ] || return 0
 MAXSYS=$(( $(grep "MemTotal: " /proc/meminfo  | awk '{print $2}' ) / 1024 / 1024 ))
 if [ $1 -gt $MAXSYS ]; then MEM=$MAXSYS; else MEM=$1; fi
 if [ ! "$2" ]; then 
    MAXMEM=$(( $MEM * 2 ));
 elif [ $2 -gt $MAXSYS ]; then
    MAXMEM=$MAXSYS
 else 
    MAXMEM=$2
 fi
 if [ $3 ]; then SLOT=$3; else SLOT=1; fi
 if [ $MEM -eq $MAXMEM ]; then
    echo "-m "$MEM"G"
 else
    echo "-m "$MEM"G,slots=$SLOT,maxmem=$MAXMEM""G"
 fi
}

# Function: Set_UEFI
# Description: Create UEFI firmware
# Args:
#   $1: VM Name
#   $2: (bool) Secure boot
function Set_UEFI() {
    SECURE=""
    [ "$2" == "on" ] && SECURE=".secboot"
        
    if [ ! -d $VMMGR_DATA_PATH/UEFI/$NAME/ ]; then 
        mkdir -p $VMMGR_DATA_PATH/UEFI/$NAME/
        cp $(rpm -ql edk2-ovmf | grep OVMF_VARS$SECURE.fd | head -1) $VMMGR_DATA_PATH/UEFI/$NAME/
        touch $VMMGR_DATA_PATH/UEFI/$NAME/OVMF_LOG.log
        sudo chown -R qemu:qemu $VMMGR_DATA_PATH/UEFI/$NAME/
        sudo chmod 660 $VMMGR_DATA_PATH/UEFI/$NAME/*
    fi
    echo "-drive if=pflash,format=raw,readonly=on,file=$(rpm -ql edk2-ovmf | grep OVMF_CODE$SECURE.fd | head -1) -drive if=pflash,format=raw,file=$VMMGR_DATA_PATH/UEFI/$NAME/OVMF_VARS$SECURE.fd -global isa-debugcon.iobase=0x402 -debugcon file:$VMMGR_DATA_PATH/UEFI/$NAME/OVMF_LOG.log"
}

# Function: Set_IPMI
# Description: Create IPMI device, using OpenIPMI-lanserv 
# Args:
#   $1: Vm Name
#   $2: IPMI Template Path
#   $3: IPMI Address
#   $4: IPMI Port
function Set_IPMI() {
  if [ ! -f /etc/ipmi/$2.conf ]; then
    cp $2 /etc/ipmi/$1.conf
    sed -i "s/%%IPMIADDR%%/$3/" /etc/ipmi/$1.conf
    sed -i "s/%%IPMIPORT%%/$4/" /etc/ipmi/$1.conf
    sed -i "s/%%NAME%%/$1/g" /etc/ipmi/$1.conf
  fi
}

# Function : Check_Existing_VM
# Description: Check on DB if VM already exists
# Args:
#   $1: VM Name
function Check_Existing_VM() {
 Set_Db $VMMGR_DB_PATH
 Db_Get_VM_Config $VMMGR_DB_PATH $1
}

# Function: Custom_VM_Config
# Description: Customize VM Configuration
# Args:
#   $1: VM name
#   $2: VM config path
function Custom_VM_Config() {
    sed -i "s/%%NAME%%/$1/g" $2
}

# Function: Customize_Unit
# Description: Customize Systemd Unit
# Args:
#   $1: VM Name
#   $2: VM config path
function Customize_Unit() {
    AFTER=""; BEFORE=""
    UNIT="$VMMGR_DATA_PATH/UNITS/$1.service"
    cp $VMMGR_DATA_PATH/UNITS/systemd-template.service $UNIT
    sed -i "s/%%NAME%%/$1/g" $UNIT
    BEFORE=$(grep "^BEFORE=" $2 | cut -d= -f 2)
    AFTER=$(grep "^AFTER=" $2 | cut -d= -f 2)
    sed -i "s/%%AFTER%%/$AFTER/g" $UNIT
    sed -i "s/%%BEFORE%%/Before=$BEFORE/g" $UNIT
    sed -i "s|%%VMMGRPATH%%|$VMMGR_PATH/VMMgr_Launcher|g" $UNIT
    INGROUP=$(Db_Get_MemberOf $VMMGR_DB_PATH $1)
    if [ "$INGROUP" ]; then
        if [ "$(Db_IsEnabled_Group $VMMGR_DB_PATH $INGROUP)" == "1" ]; then
            sed -i "s/%%WANTED%%/$INGROUP.target/g" $UNIT
        fi
    fi
    sed -i "s/%%WANTED%%/VMMgr_.target/g" $UNIT
    AUDIO=$(grep "^QEMU_AUDIO_DRV=" $2 | cut -d= -f 2)
    sed -i "s/%%AUDIO%%/$AUDIO/g" $UNIT
    sed -i "s|%%PIDFILE%%|/run/VMMGR/$1|g" $UNIT
}

# Function: Customize_Target
# Description: Customize Systemd target
# Args:
#   $1: Group Name
function Customize_Target() {
    sed -i "s|%%GROUP%%|$1|g" $VMMGR_DATA_PATH/UNITS/$1.target
}

# Function: Set_Remote_Viewer
# Description: Create .vv file for remove viewer
# Args:
#   $1: Type (spice,vnc)
#   $2: TEMPLATENAME
#   $3: VM Name
#   $4: Spice_IP_PORT ($IPPORT)
#   $5: SPICE Password
function Set_Remote_Viewer() {
    CFGPATH=$VMMGR_DATA_PATH/R-${1^^}/$3
    cp $VMMGR_DATA_PATH/R-${1^^}/$2 $CFGPATH
    sed -i "s/%%NAME%%/$3/g" $CFGPATH
    sed -i "s/%%PWD%%/$5/g" $CFGPATH
    
    CERTNAME=$(cat $CFGPATH | grep host-subject); CERTNAME=${CERTNAME#*CN=}; CERTNAME=${CERTNAME%%,*}
    
    NAMEDHOST=$(cat /etc/hosts | grep ${4%|*} | awk '{print $2}' | head -1);
    if [ "$NAMEDHOST" = "" ]; then
        NAMEDHOST=$(dig -x ${4%|*} | grep -v ";" | grep -v "^$" | head -1)
        NAMEDHOST=${NAMEDHOST##*PTR }
        if [ "$NAMEDHOST" = "" ]; then
            echo "Warning: no Hostname found matching IP: ${4%|*}"
        fi
    fi
    if [ "$CERTNAME" == "$NAMEDHOST" ]; then
        sed -i "s/%%HOSTNAME%%/$CERTNAME/g" $CFGPATH
    elif [ "$NAMEDHOST" != "" ]; then
        sed -i "s/%%HOSTNAME%%/$NAMEDHOST/g" $CFGPATH
    else
        sed -i "s/%%HOSTNAME%%/${4%|*}/g" $CFGPATH
    fi
    sed -i "s/%%PORT%%/${4#*|}/g" $CFGPATH
}

# Function VMMGR_LOG
# Description: log in /var/log/VMMGR/VMMgr.log
# Args:
#   $1: VM name
#   $2: Action
#   $3: Message
# TODO:
#      Utiliser journald
function VMMGR_LOG() {
    VMNAME=$1
    VMPROC=""
    if [ -r /run/VMMGR/VMMGR-$1 ]; then
        VMPROC=$(cat /proc/VMMGR/VMMGR-$1)
    fi
    VMMGRPROC=$$
    CDATE=$(date '+%A %d-%m-%Y %T')
    
    if [ "$VMNAME" == "VMMGR" ]; then
        echo "$CDATE VMMgr: [$2] pid=$VMMGRPROC msg=$3" >> /var/log/VMMgr/VMMgr.log
    else
        [ -w /var/log/VMMgr/$VMNAME-log ] ||  touch /var/log/VMMgr/$VMNAME-log
        echo "$CDATE VMMgr: [$2] pid=$VMPROC msg=$3" >> /var/log/VMMgr/$VMNAME-log
    fi
}

# Function: Start_VM_From_Config
# Description: Start VM using VM Config file
#               Here, we create many things
# Args:
#   $1: VM Name
#   $2: VM config path
function Start_VM_From_Config() {
    echo "starting $1"
    if [ -r /etc/VMMGR/VMMgr_.conf ]; then
        . /etc/VMMGR/VMMgr_.conf
    elif [ -r $(dirname $0)/VMMgr_.conf ]; then
        . $(dirname $0)/VMMgr_.conf
    else
        echo "No config VMMgr_.conf found, abording..."
        return
    fi
    . $VMMGR_DATA_PATH/DATA/VMMgr_Devices
    Get_Bridge_Tool
    
    ### SPICE ###
    . $VMMGR_DATA_PATH/DATA/VMMgr_Spice
    . $2
    if [ "$SPICE" == "on" ]; then
        IPPORT=$(Set_Service_Listen $SPICEIP $SPICEIPVER $SPICETYPE $NAME spice $SPICEPORT)
        SPICEIP=${IPPORT%|*}; SPICEPORT=${IPPORT#*|}
        . $VMMGR_DATA_PATH/DATA/VMMgr_Spice
        Set_Remote_Viewer spice $SPICETPL $NAME $IPPORT $SPICEPWD
    else
        SPICETPL=TPLNULL
    fi
    
    ### TELNET MONITOR ###
    if [ "$TELNET" == "on" ]; then
        IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
        TELNETTPL="-monitor telnet:$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'):${IPPORT#*|},server,nowait"
    else
        TELNETTPL=""
    fi

    ### VNC ###
    if [ "$VNC" == "on" ]; then
        . $VMMGR_DATA_PATH/DATA/VMMgr_VNC
        . $2
        IPPORT=$(Set_Service_Listen $VNCIP $VNCIPVER $VNCTYPE $NAME vnc $VNCPORT)
        VNCIP=$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'); VNCPORT=${IPPORT#*|}
        . $VMMGR_DATA_PATH/DATA/VMMgr_VNC
        echo "Remote Viewer with x509 do not work, please use another vnc viewer like Remina"
        Set_Remote_Viewer vnc $VNCTPL $NAME $IPPORT $VNCPWD
    else
        VNCTPL=TPLNULL
    fi
    
    ### QMP MONITOR ###
    if [ "$QMP" == "on" ]; then
        IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
        QMPTPL="-chardev socket,id=qmp01,host=$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'),port=${IPPORT#*|},server,nowait -mon chardev=qmp01,mode=control,pretty=on"
    else
        QMPTPL=""
    fi

    ### Virtio NETWORK ###
    . $VMMGR_DATA_PATH/DATA/VMMgr_VirtioNet
    
    declare -i NUMDEV=0
    for NET in $(echo $NETWORKDEVICE); do
        NETARRAY="$NETARRAY $(Set_NetDev $NAME ${NET%|*} ${NET#*|} "$NETDEV" "$DEVICE" $NUMDEV)"
        NUMDEV=$(( $NUMDEV + ${NET#*|} ))
    done
    
    ### Virtio Disks ###
    if [ "$Virtio_Disk" ]; then
        export Virtio_Disk
        DisksList=$(Set_Disks $NAME)
        VIRTIODISKS=$(Set_Virtio_Disks $NAME $IOTHREADS $DisksList)
        unset Virtio_Disk
    fi
    
    ### SCSI Disks ###
    if [ "$Scsi_Disk" ]; then
        export Scsi_Disk
        DisksList=$(Set_SDisks $NAME)
        SCSIDISKS=$(Set_Scsi_Disks $NAME $DisksList)
        unset Scsi_Disk
    fi
    
    ### CPU/SMP/NUMA/MACHINE ###
    . $VMMGR_DATA_PATH/DATA/VMMgr_CPU
    CORE="-machine ${!MACHINETPL} ${!SMPTPL} -cpu ${!CPU}"
    MEMORY=$(Check_MEM $MEM $MAXMEM $SLOT)
    
    ### BIOS/UEFI
    SETUPSECUREBOOT=0
    if [ "$BIOSTYPE" == "BIOS" ]; then
        FIRMWARE=$BIOS
        echo "BIOS=$FIRMWARE"
    elif [ "$BIOSTYPE" == "UEFI" ]; then
       FIRMWARE=$(Set_UEFI $NAME)
    elif [ "$BIOSTYPE" == "SECURE" ]; then
        [ ! -d $VMMGR_DATA_PATH/UEFI/$NAME/ ] && SETUPSECUREBOOT="1"
        FIRMWARE=$(Set_UEFI $NAME on)
    fi
    
    UUID="-uuid "$(Get_Db_UUID $VMMGR_DB_PATH $NAME)
    
    ### Ok! Now we can start VM ###
    if [ "$VMMGR_TEST" == "TEST" ]; then
        echo "qemu-system-x86_64 -pidfile /run/VMMGR/$NAME -name $NAME $UUID $CORE $MEMORY $FIRMWARE ${!QEMU_TEMPLATE} ${!SPICETPL} ${!VNCTPL} $QMPTPL $TELNETTPL $NETARRAY $VIRTIODISKS $SCSIDISKS -writeconfig $VMMGR_DATA_PATH/QEMU_CONFIGS/$NAME"
    else
        WCONFIG="-writeconfig $VMMGR_DATA_PATH/QEMU_CONFIGS/$NAME"
        qemu-system-x86_64 -pidfile /run/VMMGR/$NAME -name $NAME $UUID $CORE $MEMORY $FIRMWARE ${!QEMU_TEMPLATE} $NETARRAY ${!SPICETPL} ${!VNCTPL} $QMPTPL $TELNETTPL $VIRTIODISKS $SCSIDISKS $WCONFIG
        
        sleep 1
        
        # Fix Duplicated ID compat_monitor0 #
        sed -i 's/compat_monitor0/compat_monitor1/g' $VMMGR_DATA_PATH/QEMU_CONFIGS/$NAME
        
        # insert missing options, the following options are not included in qemu config:
        # pidfile, uuid, display, soundhw, daemonize, no-user-config, nodefaults
        # we add uuid, soundhw and display as comments
        
        DISPLAY=${!QEMU_TEMPLATE}; DISPLAY=${DISPLAY##*-display}; DISPLAY=${DISPLAY%%-*}
        if [ "$DISPLAY" != "" ]; then ADDED="# display $DISPLAY\n"; fi
        SOUND=${!QEMU_TEMPLATE}; SOUND=${SOUND##*-soundhw}; SOUND=${SOUND%%-*}
        if [ "$SOUND" != "" ]; then ADDED="$ADDED# soundhw $SOUND\n"; fi
        if [ "${!CPU}" != "" ]; then ADDED="$ADDED# cpu ${!CPU}\n"; fi
        sed -i -e "s/^\(\# qemu config file\)$/\1\n$ADDED/" $VMMGR_DATA_PATH/QEMU_CONFIGS/$NAME

        
        ### VNC PASSWORD ###
        if [ "$VNC" == "on" ]; then
            if [ "$TELNET" == "on" ]; then
                TIP=${TELNETTPL##*monitor telnet:}
                TIP=${TIP%%,server,nowait}
                { echo "set_password vnc $VNCPWD"; sleep 1; } | telnet ${TIP%:*} ${TIP##*:}
            elif [ "$QMP" == "on" ]; then
                TIP=${QMPTPL##*chardev socket,id=qmp01,host=}
                TIP=${TIP%%,server,nowait*}
                { echo '{ "execute": "qmp_capabilities" } { "execute": "set_password vnc $VNCPWD" }'; sleep 1; } | telnet ${TIP%%,*} ${TIP##*port=}
            fi
        fi
        
        ### Checking if vm is running ###
        if [ "$TELNET" == "on" ]; then
            TIP=${TELNETTPL##*monitor telnet:}
            TIP=${TIP%%,server,nowait}
            { echo "info status"; sleep 1; } | telnet ${TIP%:*} ${TIP##*:}
        elif [ "$QMP" == "on" ]; then
            TIP=${QMPTPL##*chardev socket,id=qmp01,host=}
            TIP=${TIP%%,server,nowait*}
            { echo '{ "execute": "qmp_capabilities" } { "execute": "query-status" }'; sleep 1; } | telnet ${TIP%%,*} ${TIP##*port=}
        fi
        
        ### Load Install DVD and reset
        INSERTDVD=$(cat $2 | grep '^INSTALLISO' | cut -d= -f2 | tr -d \" )
        if [ "$INSERTDVD" ]; then
             $VMMGR_PATH/VMMgr_Launcher load $NAME $INSERTDVD reset
             sed -i -e 's/\(^INSTALLISO=.*$\)/#\1/' $2
        fi
    fi
}

# Function: Install_VMMGR
# Description: Install VMMGR on the system
# Args: None
function Install_VMMGR() {
    # /etc/VMMGR/ and main config VMMgr_.conf
    if [ ! -d /etc/VMMGR/ ]; then
        mkdir /etc/VMMGR
        cp -r $(pwd)/VMMgr_.conf /etc/VMMGR/ && chown -R qemu:qemu /etc/VMMGR
        sed -i 's/^\(\VMMGR_.*\)$//g' /etc/VMMGR/VMMgr_.conf
        sed -i 's/^#\(\VMMGR_.*\)$/\1/g' /etc/VMMGR/VMMgr_.conf
    fi
    # /var/lib/VMMGR/
    [ -d /var/lib/VMMGR/ ] || mkdir -p /var/lib/VMMGR/{DB,ISO}
    cp -r $(pwd)/{Configs,DATA,DB_BKP,VM_BKP,QEMU_CONFIGS,R-SPICE,R-VNC,TAPSCRIPTS,Templates,UEFI,VM_CONFIGS,UNITS} /var/lib/VMMGR/ && chown -R qemu:qemu /var/lib/VMMGR && chmod -R 770 /var/lib/VMMGR
    
    # Main program
    cp $(pwd)/VMMgr_Launcher /usr/local/bin/ && chown qemu:qemu /usr/local/bin/VMMgr_Launcher && chmod 0755 /usr/local/bin/VMMgr_Launcher
    
    # Libs
    cp -r $(pwd)/VMMgr_Libs/VMMgr_* /usr/local/lib/ && chown qemu:qemu /usr/local/lib/VMMgr_* && chmod 0650 /usr/local/lib/VMMgr_*
    
    # DB
    [ -r $(pwd)/VMMGR_.db ] && cp -r $(pwd)/VMMGR_.db /var/lib/VMMGR/DB/ && chown qemu:qemu /var/lib/VMMGR/DB/VMMGR_.db && chmod 0660 /var/lib/VMMGR/DB/VMMGR_.db
    
    # /run/VMMGR
    if [ ! -d /run/VMMGR ]; then
        mkdir /run/VMMGR && chown -R qemu:qemu /run/VMMGR && chmod -R 770 /run/VMMGR
    fi
    
    # /var/log/VMMGR
    if [ ! -d /var/log/VMMgr ]; then
        mkdir /var/log/VMMgr
        touch /var/log/VMMgr/VMMgr.log
        chown -R qemu:qemu /var/log/VMMgr
        chmod 770 /var/log/VMMgr
        chmod 660 /var/log/VMMgr
    fi
    
    if [ ! -r /etc/systemd/system/VMMgr_.target ]; then
        cp $(pwd)/UNITS/VMMgr_.target /etc/systemd/system/
    fi
    if [ ! -d /etc/systemd/system/VMMgr_.target.wants ]; then
        mkdir /etc/systemd/system/VMMgr_.target.wants
    fi
    VMMGR_LOG "VMMGR" "INSTALL" "VMMgr is installed on your system."
}

# Function: Uninstall_VMMGR
# Description: Remove VMMGR from the system
# Args: None
function Uninstall_VMMGR() {
    # DB
    if [ -r /var/lib/VMMGR/DB/VMMGR_.db ]; then
        echo "Before Uninstall, do you want to save your DB? [Y/n]"; read answer
        if [ "${answer^^}" == "Y" ] || [  "$answer" == "" ]; then
            cp /var/lib/VMMGR/DB/VMMGR_.db ~/VMMgr_.db.bkp$(date --iso)
            echo "VMMGR_.db saved to: ~/VMMgr_.db.bkp$(date --iso)"
        fi
        rm /var/lib/VMMGR/DB/VMMGR_.db
    fi
    # DB Backups
    if [ "$(ls -I README.md /var/lib/VMMGR/DB_BKP)" != "" ]; then
        echo "Do you want to save you DB backup? [y/N]"; read answer
        if [ "${answer^^}" == "Y" ]; then
            cp -r /var/lib/VMMGR/DB_BKP ~/VMMgr_.DB_BKP
            echo "DB backups saved to: ~/DB_BKP"
        fi
    fi
    
    rm /usr/local/bin/VMMgr_Launcher
    rm /usr/local/lib/VMMgr_{CPUs,Db,Disks,Functions,Networks}
    VMMGR_LOG "VMMGR" "UNINSTALL" "VMMgr is installed on your system except:"
    VMMGR_LOG "VMMGR" "UNINSTALL" "/etc/VMMGR directory will not be deleted"
    VMMGR_LOG "VMMGR" "UNINSTALL" "/var/lib/VMMGR, VM configs and templates will not be deleted"
}

# Function VM_Is_Running
# Description: check if vm is running
# Args:
#   $1: VM name
function VM_Is_Running() {
    if [ -r "/run/VMMGR/$1" ]; then
        Result=$(ps -h -q $(cat /run/VMMGR/$1) -o pid)
        if [ "${Result# }" == "$(cat /run/VMMGR/$1)" ]; then
            echo 1
        else
            echo 0
        fi
    else
        echo 0
    fi
}

# Function: List_All_VM
# Description: Get the list of VMs
# Args:
#   $1: [all|running|stopped|enabled|disabled]
function List_All_VM() {
    case "$1" in
            "all")
                VMS=$(Db_List_VMs $VMMGR_DB_PATH)
                for VM in $VMS; do
                    edb="disabled"; esys="disabled"; isrun="stopped"
                    Enabled=$(Db_isEnabled_VM $VMMGR_DB_PATH $VM)
                    if [ "$Enabled" == "1" ]; then
                        edb="enabled"
                    fi
                    systemctl --quiet is-enabled $VM 2>/dev/null
                    if [ $? -eq 0 ]; then
                       esys="enabled"
                    fi
                    Running=$(VM_Is_Running $VM)
                    if [ "$Running" == 1 ]; then
                      isrun="running"
                    fi
                    echo "$VM: $edb(DB), $esys(systemd): $isrun"
                done
            ;;
            "running")
                VMS=$(Db_List_VMs $VMMGR_DB_PATH)
                for VM in $VMS; do
                    Running=$(VM_Is_Running $VM)
                    if [ "$Running" == "1" ]; then
                        echo $VM
                    fi
                done
            ;;
            "enabled")
                Db_Filter_VMs $VMMGR_DB_PATH Enabled 1
                
            ;;
            "stopped")
                VMS=$(Db_List_VMs $VMMGR_DB_PATH)
                for VM in $VMS; do
                    Running=$(VM_Is_Running $VM)
                    if [ "$Running" == "0" ]; then
                        echo $VM
                    fi
                done
            ;;
            "disabled")
                Db_Filter_VMs $VMMGR_DB_PATH Enabled 0
            ;;
    esac
}

# Args:
#   $1: VM name
function VM_Get_Order() {
    VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $1)
    VMORDER=$(cat $VMMGR_DATA_PATH/VM_CONFIGS/$VMCONF | grep "^ORDER=")
    echo ${VMORDER#ORDER=}
}
# Args:
#   $1: VM Name
function Get_Start_Wait() {
    VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $1)
    VMCOND=$(cat $VMCONF | grep "^STARTWAIT=")
    echo ${VMCOND#GROUP=}
}

# Function: Manage_Group
# Description: Dispatcher for group management
# Args:
#   $1: action
#   $2: group name
function Manage_Group() {
    case $1 in
        "list")
            case $2 in
                "all")
                    Db_Get_Groups $VMMGR_DB_PATH
                ;;
                *)
                    Db_Get_Group_Member $VMMGR_DB_PATH $2
                ;;
            esac
        ;;
        "start")
            if [ "$(Db_IsEnabled_Group $VMMGR_DB_PATH $2)" == "1" ]; then
                sudo systemctl start $2.target
            else
                MEMBERS=$(Db_Get_Group_Member $VMMGR_DB_PATH $2)                # Get Group Members
                ORDER=""; WAIT=""; PREC=""
                for MEMBER in $MEMBERS; do                                      # Ordering
                    VMO=$(VM_Get_Order $MEMBER)
                    [ "$VMO" ] || VMO=1000
                    ORDER="$ORDER $VMO;$MEMBER"
                done
                for MEMBER in $ORDER; do
                    if [ "$PREC" ]; then
                        if [ "$PREC" == ${MEMBER%;*} ]; then                    # Same order value, we start
                            $VMMGR_PATH/VMMgr_Launcher start ${MEMBER#*;}
                            PREC=${MEMBER%;*}
                        else
                            WAIT=$(Get_Start_Wait ${MEMBER#*;})
                            if [ "${WAIT^^}" == "YES" ]; then
                                ISOK="1"; COUNT=0
                                until [ $ISOK -eq 0 ]; do
                                    systemctl -H "get 1rst IP" is-system-running 2>&1
                                    ISOK=$?
                                    COUNT=$(( COUNT + 1 ))
                                    echo $COUNT
                                    if [ $COUNT -gt 30 ]; then break; fi
                                    sleep 5
                                done
                                if [ $ISOK -eq 0 ]; then
                                    $VMMGR_PATH/VMMgr_Launcher start ${MEMBER#*;}
                                    PREC=${MEMBER%;*}
                                else
                                    break;
                                fi
                            else
                                sleep $WAIT
                                $VMMGR_PATH/VMMgr_Launcher start ${MEMBER#*;}
                                PREC=${MEMBER%;*}
                            fi
                        fi
                    else
                        $VMMGR_PATH/VMMgr_Launcher start ${MEMBER#*;}                  # First VM
                        PREC=${MEMBER%;*}
                    fi
                done
            fi
            ;;
        "stop")
            # on doit gÃ©rer le target et systemd?
            for MEMBER in $(Db_Get_Group_Member $VMMGR_DB_PATH $2); do
                $VMMGR_PATH/VMMgr_Launcher stop $MEMBER
            done
        ;;
        "enable")
            TARGET=$(systemctl list-unit-files $2.target | grep 1)
            cp $VMMGR_DATA_PATH/UNITS/group-template.target $VMMGR_DATA_PATH/UNITS/$2.target
            Customize_Target $2
            if [ ! "$TARGET" ]; then
                UNITPATH=$(systemctl status $2.target | grep "Loaded:" | cut -d\( -f2 ); UNITPATH="${UNITPATH%%.target*}.target"
                if [ "$(sha1sum $VMMGR_DATA_PATH/UNITS/$2.target | awk '{print $1}')" == "$(sha1sum $UNITPATH | awk '{print $1}')" ]; then
                    echo "VM $2 already enabled"
                else
                    sudo cp $VMMGR_DATA_PATH/UNITS/$2.target /etc/systemd/system/$2.target
                    sudo systemctl daemon-reload
                fi
            else
                sudo cp $VMMGR_DATA_PATH/UNITS/$2.target /etc/systemd/system/$2.target
                sudo systemctl daemon-reload
                [ -d /etc/systemd/system/$2.target.wants ] || sudo mkdir /etc/systemd/system/$2.target.wants
            fi
            Db_Enable_Group $VMMGR_DB_PATH $2
            for MEMBER in $(Db_Get_Group_Member $VMMGR_DB_PATH $2); do
                $VMMGR_PATH/VMMgr_Launcher enable $MEMBER
            done
        ;;
        "disable")
            for MEMBER in $(Db_Get_Group_Member $VMMGR_DB_PATH $2); do
                $VMMGR_PATH/VMMgr_Launcher disable $MEMBER
            done
            sudo systemctl disable $2.target
            Db_Disable_Group $VMMGR_DB_PATH $2
        ;;
    esac
}

# Function: VM_Delete
# Description: Delete a vm
# Args:
#   $1: VM Name
#   $2: VM config file
#   $3: =$3 from VMMgr_Launcher command
function VM_Delete() {
    for i in $(echo $3 | tr \- \  ); do
        case $i in
            "db")
                Db_Delete_VM $VMMGR_DB_PATH $1
            ;;
            "conf")
                rm $VMMGR_DATA_PATH/VM_CONFIGS/$2
                rm $VMMGR_DATA_PATH/QEMU_CONFIGS/$1
            ;;
            "disks")
                if [ ! -r $VMMGR_DATA_PATH/VM_CONFIGS/$2 ]; then
                    echo "Missing Config, cannot find disks"
                else
                    . $VMMGR_DATA_PATH/VM_CONFIGS/$2
                    if [ "$Virtio_Disk" ]; then
                        export Virtio_Disk
                        DisksList=$(Set_Disks $NAME 1)
                        for Disk in $(echo $DisksList | tr \|  \  ); do
                            rm $Disk
                        done
                        unset Virtio_Disk
                    fi
                    if [ "$Scsi_Disk" ]; then
                        export Scsi_Disk
                        DisksList=$(Set_SDisks $NAME)
                        for Disk in $(echo $DisksList | tr \|  \  ); do
                            rm $Disk
                        done
                        unset Scsi_Disk
                    fi
                fi
            ;;
        esac
    done
}

# Function: VM_DB_Manage
# Description: Many DB management tasks
# Args:
#   $1: operation
#   $2: arg for $1
function VM_DB_Manage() {
    case $1 in
        "reconf") # $2 = <vm name>
            VMCONF=$(Db_Get_VM_Config $VMMGR_DB_PATH $2)
            if [ ! "$VMCONF" ]; then
                echo "VM $2 not found in db"
            else
                echo "please select a template" && read template
                if [ "$template" ] && [ -r $VMMGR_DATA_PATH/Templates/$template ] ; then
                    cp $VMMGR_DATA_PATH/Templates/$template $VMMGR_DATA_PATH/VM_CONFIGS/$VMCONF
                    Custom_VM_Config $2 $VMMGR_DATA_PATH/VM_CONFIGS/$VMCONF
                else
                    echo "Template not found"
                fi
            fi
        ;;
        "todb")
            if [ -r $VMMGR_DATA_PATH/VM_CONFIGS/$2 ]; then
                VMCONF="$VMMGR_DATA_PATH/VM_CONFIGS/$2"
                VMTPL=$(cat $VMCONF | grep "^# Template Name: "); VMTPL=${VMTPL#\#Template Name: }
                VMNAME=$(cat $VMCONF | grep "^NAME=" cut -d\" -f2);
                VMGRP=$(cat $VMCONF | grep "^GROUP=" | cut -d\" -f2)
                EXIST=$(Db_Get_VM_Config $VMMGR_DB_PATH $VMNAME)
                if [ "$EXIST" ]; then
                    echo "Error, VM already exists in db"
                else
                    VMID=$(Db_Create_VM $VMMGR_DB_PATH $VMNAME $(basename VMCONF) $(cat /proc/sys/kernel/random/uuid) $VMGRP)
                    Db_Set_Group $VMMGR_DB_PATH $VMNAME $VMGRP
                fi
            else
                echo "error $VMMGR_DATA_PATH/VM_CONFIGS/$2 not found"
            fi
        ;;
        "export")
            Db_Export_VM $VMMGR_DB_PATH $2
        ;;
        "import")
            Db_Import_VM $VMMGR_DB_PATH $2
        ;;
        "backup")
            if [ "$2" == "list" ]; then
                for BKPFILE in $(ls --hide=README.md -r $VMMGR_DATA_PATH/DB_BKP/*.bkp); do
                    basename $BKPFILE
                done
            fi
        ;;
        "restore")
            if [ "$2" == "last" ]; then
                LATEST=$( ls -1r $VMMGR_DATA_PATH/DB_BKP/*-DB.bkp | head -1)
                if [ -r "$LATEST" ]; then
                    cp $LATEST $VMMGR_DB_PATH/VMMGR_.db
                else
                    echo "no latest backup found"
                fi
            else
                BKP=$( ls $VMMGR_DATA_PATH/DB_BKP/$2)
                if [ -r "$BKP" ]; then
                    cp $BKP $VMMGR_DATA_PATH/DB/VMMGR_.db
                else
                    echo "no latest backup found"
                fi
            fi
        ;;
        "purge")
            if [ "$DBMAXAGE" ]; then
                for BKPFILE in $(ls --hide=README.md -r $VMMGR_DATA_PATH/DB_BKP/*DB.bkp); do
                BKPNAME=$(basename $BKPFILE)
                    BKPDATE=${BKPNAME%%_*}
                    BKPDATE=$(date -d $BKPDATE +%s)
                    CURDATE=$(date --date "$DBMAXAGE days ago" +%s)
                    if [ $BKPDATE -lt $CURDATE ]; then
                        echo "on doit delete $BKPFILE"
                    else
                        echo "on conserve $BKPFILE"
                    fi
                done
            fi
            if [ "$DBMAXBACKUP" ]; then
                BKPCOUNT=0
                for BKPFILE in $(ls --hide=README.md -r $VMMGR_DATA_PATH/DB_BKP/*.bkp); do
                    BKPCOUNT=$(( $BKPCOUNT + 1 ))
                    if [ $BKPCOUNT -gt $DBMAXBACKUP ]; then
                       rm $BKPFILE
                    fi
                done
            fi
        ;;
    esac
}
