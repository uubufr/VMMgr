#! /bin/bash
#
# script name: VMMgr_Functions
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: All usefull functions
#
# Functions:
# Check_Softwares: try to check if all required software are installed
# Check_System: Check system requirements
# Check_MEM: Check if MEM and MAXMEM, if MAXMEM is undefined, calculate MEM * 2
# Set_NetDev: Create tap interfaces
# Set_IPMI: Create IPMI device, using OpenIPMI-lanserv 
# Custom_VM_Config: Customize VM Configuration
#

## TODO:
## Créer des units systemd
## créer les fichiers spice
## créer un tableau de numa
# créer un tableau de périphériques disque



# Function Check_Softwares
# Description: try to check if all required software are installed
# Args: no args
function Check_Softwares() {
    qemu-system_x86_64
    openIPMI_lanserv
    sqlite3
}

# Function: Check_System
# Description: Check system requirements
# Args: no args
# Steps:
#   1: Check module vhost-net
#   2: Check perms on /dev/net/tun, /dev/vhost-net and /dev/kvm
#   3: Set cap_net_admin on qemu-system_x86_64
function Check_System() {
    if [ "$(sudo modinfo vhost-net -F intree)" != "Y" ]; then
        sudo modprobe vhost vhost-net
    fi
    
    ls -l /dev/net/tun | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/net/tun
    fi

    ls -l /dev/vhost-net | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/vhost-net
    fi

    ls -l /dev/kvm | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/kvm
    fi

    sudo getcap /usr/bin/qemu-system-x86_64 | grep cap_net_admin+ep > /dev/null
    if [ $? -ne 0 ]; then
        sudo setcap cap_net_admin+ep /usr/bin/qemu-system-x86_64
    fi
    
    # On a besoin de voir comment faire dans sudo pour que ça fonctionne
    #if [ $(cat /proc/sys/net/ipv4/ip_forward) -eq 0 ]; then
        #sudo echo 1 > /proc/sys/net/ipv4/ip_forward
    #fi
    
    modinfo openvswitch 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        sudo modprobe openvswitch
        [ -d /var/run/openvswitch ] || sudo mkdir /var/run/openvswitch
    fi
}


# Function Check_MEM
# Description: Check if MEM and MAXMEM
# if MAXMEM is undefined, calculate MEM * 2
# Args:
#   $1: $MEM
#   $2: $MAXMEM
function Check_MEM() {
 if [ "$1" ]; then
  if [ "$2" ]; then
   echo $2
  else
   MAXMEM=$(( $1 * 2 ))
   MAXSYS=$(( $(grep "MemTotal: " /proc/meminfo  | awk '{print $2}' ) / 1024 / 1024 ))
   if [ $MAXMEM -gt $MAXSYS ]; then $MAXMEM == $MAXSYS; fi
   echo $MAXMEM
  fi
 else
   return 0
 fi
}

# Function: Set_NetDev
# Description: Create tap interfaces
# Args:
#   $1: VM Name
#   $2: Bridge name
#   $3: Number of tap devices
#   $4: -netdev template
#   $5: -device template
#   $6: Addr
function Set_NetDev() {
    Create_Bridge $2 $BRIDGETOOL on
    for NETNUMBER in $(seq 1 $3 ); do
        MAC="mac="$(Set_MAC $VMMGR_DB_PATH $(( $6 + $NETNUMBER )) $1)
        TAPUP="script=$VMMGR_DATA_PATH/TAPSCRIPTS/tapup-$2"
        TAPDOWN="downscript=$VMMGR_DATA_PATH/TAPSCRIPTS/tapdown-$2"
        [ -r "$VMMGR_DATA_PATH/TAPSCRIPTS/tapup-$2" ] || ln $VMMGR_DATA_PATH/TAPSCRIPTS/tapup $VMMGR_DATA_PATH/TAPSCRIPTS/tapup-$2
        [ -r "$VMMGR_DATA_PATH/TAPSCRIPTS/tapdown-$2" ] || ln $VMMGR_DATA_PATH/TAPSCRIPTS/tapdown $VMMGR_DATA_PATH/TAPSCRIPTS/tapdown-$2
        echo "-netdev tap,id=virtio-tap$(( $6 + $NETNUMBER )),$TAPUP,$TAPDOWN,$4 -device virtio-net-pci,netdev=virtio-tap$(( $6 + $NETNUMBER )),$MAC,id=drive-virtio-tap$(( $6 + $NETNUMBER )),$5 "
     done
}

# Function: Set_IPMI
# Description: Create IPMI device, using OpenIPMI-lanserv 
# Args:
#   $1: Vm Name
#   $2: IPMI Template Path
#   $3: IPMI Address
#   $4: IPMI Port
function Set_IPMI() {
  if [ ! -f /etc/ipmi/$2.conf ]; then
    cp $2 /etc/ipmi/$1.conf
    sed -i "s/%%IPMIADDR%%/$3/" /etc/ipmi/$1.conf
    sed -i "s/%%IPMIPORT%%/$4/" /etc/ipmi/$1.conf
    sed -i "s/%%NAME%%/$1/g" /etc/ipmi/$1.conf
  fi
}

# Function : Check_Existing_VM
# Description: Check on DB if VM already exists
# Args:
#   $1: VM Name
function Check_Existing_VM() {
 Set_Db $VMMGR_DB_PATH
 Db_Get_VM_Config $VMMGR_DB_PATH $1
}

# Function: Custom_VM_Config
# Description: Customize VM Configuration
# Args:
#   $1: VM name
#   $2: VM config path
function Custom_VM_Config() {
    sed -i "s/%%NAME%%/$1/g" $2
}

# Function: Set_Remote_Viewer
# Description: Create .vv file for remove viewer
# Args:
#   $1: Type (spice,vnc)
#   $2: TEMPLATENAME
#   $3: VM Name
#   $4: Spice_IP_PORT ($IPPORT)
#   $5: SPICE Password
function Set_Remote_Viewer() {
    CFGPATH=$VMMGR_CONFIG_PATH/R-${1^^}/$3
    cp $VMMGR_CONFIG_PATH/R-${1^^}/$2 $CFGPATH
    sed -i "s/%%NAME%%/$3/g" $CFGPATH
    sed -i "s/%%PWD%%/$5/g" $CFGPATH
    
    CERTNAME=$(cat $CFGPATH | grep host-subject); CERTNAME=${CERTNAME#*CN=}; CERTNAME=${CERTNAME%%,*}
    
    NAMEDHOST=$(cat /etc/hosts | grep ${4%|*} | awk '{print $2}' | head -1);
    if [ "$NAMEDHOST" = "" ]; then
        NAMEDHOST=$(dig -x ${4%|*} | grep -v ";" | grep -v "^$" | head -1)
        NAMEDHOST=${NAMEDHOST##*PTR }
        if [ "$NAMEDHOST" = "" ]; then
            echo "Warning: no Hostname found matching IP: ${4%|*}"
        fi
    fi
    if [ "$CERTNAME" == "$NAMEDHOST" ]; then
        sed -i "s/%%HOSTNAME%%/$CERTNAME/g" $CFGPATH
    elif [ "$NAMEDHOST" != "" ]; then
        sed -i "s/%%HOSTNAME%%/$NAMEDHOST/g" $CFGPATH
    else
        sed -i "s/%%HOSTNAME%%/${4%|*}/g" $CFGPATH
    fi
    sed -i "s/%%PORT%%/${4#*|}/g" $CFGPATH
}

# Function: Start_VM_From_Config
# Description: Start VM using VM Config file
# Args:
#   $1: VM Name
#   $2: VM config path
function Start_VM_From_Config() {
    echo "starting $2"
    if [ -r /usr/local/etc/VMMgr_.conf ]; then
        . /usr/local/etc/VMMgr_.conf
    elif [ -r $(dirname $0)/VMMgr_.conf ]; then
        . $(dirname $0)/VMMgr_.conf
    else
        echo "No config VMMgr_.conf found, abording..."
        return
    fi
    . $VMMGR_CONFIG_PATH/DATA/VMMgr_Spice
    . $2
    Get_Bridge_Tool
    
    if [ "$SPICE" == "on" ]; then
        IPPORT=$(Set_Service_Listen $SPICEIP $SPICEIPVER $SPICETYPE $NAME spice $SPICEPORT)
        SPICEIP=${IPPORT%|*}; SPICEPORT=${IPPORT#*|}
        . $VMMGR_CONFIG_PATH/DATA/VMMgr_Spice
        Set_Remote_Viewer spice $SPICETPL $NAME $IPPORT $SPICEPWD
    else
        SPICETPL=TPLNULL
    fi
    . VMMgr_Vars
    
    if [ "$TELNET" == "on" ]; then
        IPPORT=$(Set_Service_Listen $TELNETIP $TELNETIPVER $TELNETTYPE $NAME telnet $TELNETPORT)
        TELNETTPL="-monitor telnet:$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'):${IPPORT#*|},server,nowait"
    else
        TELNETTPL=""
    fi

    
    if [ "$VNC" == "on" ]; then
        . $VMMGR_CONFIG_PATH/DATA/VMMgr_Spice
        . $2
        IPPORT=$(Set_Service_Listen $VNCIP $VNCIPVER $VNCTYPE $NAME vnc $VNCPORT)
        VNCIP=$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'); VNCPORT=${IPPORT#*|}
        . $VMMGR_CONFIG_PATH/DATA/VMMgr_VNC
        echo "Remote Viewer with x509 do not work, please use another vnc viewer like Remina"
        Set_Remote_Viewer vnc $VNCTPL $NAME $IPPORT $VNCPWD
    else
        VNCTPL=TPLNULL
    fi
    
    if [ "$QMP" == "on" ]; then
        IPPORT=$(Set_Service_Listen $QMPIP $QMPIPVER $QMPTYPE $NAME qmp $QMPPORT)
        QMPTPL="-chardev socket,id=qmp01,host=$(ip -br a s | grep ${IPPORT%|*} | awk '{print $1}'),port=${IPPORT#*|},server,nowait -mon chardev=qmp01,mode=control,pretty=on"
    else
        QMPTPL=""
    fi

    . $VMMGR_CONFIG_PATH/DATA/VMMgr_VirtioNet
    
    declare -i NUMDEV=0
    for NET in $(echo $NETWORKDEVICE); do
        NETARRAY="$NETARRAY $(Set_NetDev $NAME ${NET%|*} ${NET#*|} "$NETDEV" "$DEVICE" $NUMDEV)"
        NUMDEV=$(( $NUMDEV + ${NET#*|} ))
    done
    
    export Virtio_Disk
    DisksList=$(Set_Disks $NAME)
    VIRTIODISKS=$(Set_Virtio_Disks $NAME $IOTHREADS $DisksList)
    unset Virtio_Disk
    
    sleep 2
    echo "qemu-system-x86_64 ${!QEMU_TEMPLATE} ${!SPICETPL} ${!VNCTPL} $QMPTPL $TELNETTPL $NETARRAY $VIRTIODISKS"
    qemu-system-x86_64 ${!QEMU_TEMPLATE} ${!SPICETPL} ${!VNCTPL} $QMPTPL $TELNETTPL $NETARRAY $VIRTIODISKS
    sleep 2
    if  [ "$VNC" == "on" ] && [ "$VNCPWD" != "" ]; then
            { echo "set_password vnc $VNCPWD"; sleep 1; } | telnet $VNCIP $VNCPORT
    fi
    if [ "$TELNET" == "on" ]; then
        TIP=${TELNETTPL##*monitor telnet:}
        TIP=${TIP%%,server,nowait}
        { echo "info status"; sleep 1; } | telnet ${TIP%:*} ${TIP##*:}
    fi
    
    if [ "$QMP" == "on" ]; then
        TIP=${QMPTPL##*chardev socket,id=qmp01,host=}
        TIP=${TIP%%,server,nowait*}
        { echo '{ "execute": "qmp_capabilities" } { "execute": "query-status" }'; sleep 1; } | telnet ${TIP%%,*} ${TIP##*port=}
    fi
}



### ToDo ###
# virtio-win:
# stable: https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso
# latest:https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso
# qemu-ga: https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/archive-qemu-ga/qemu-ga-win-100.0.0.0-3.el7ev/qemu-ga-x64.msi
# Spice-guest-tools: https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe
