#! /bin/bash
#
# script name: VMMgr_Functions
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: All usefull functions
#
# Functions:
# Check_Softwares: try to check if all required software are installed
# Check_System: Check system requirements
# Set_Bridge_Brctl: Set bridges using brctl
# Set_Bridge_Ovs: Create bridge using openvswitch
# Set_Bridge_Nmcli: create bridge using nmcli
# Check_MEM: Check if MEM and MAXMEM, if MAXMEM is undefined, calculate MEM * 2
# Set_NetDev: Create tap interfaces
# Set_MAC: Calculate MAC Address
# Set_IPMI: Create IPMI device, using OpenIPMI-lanserv 
# Custom_VM_Config: Customize VM Configuration


## TODO: Create tapup and links (using brctl, ovs-brctl or nmcli)
## Créer des units systemd
## créer les fichiers spice
## créer un tableau de numa
# créer un tableau de périphériques disque
# créer les connexions réseau
# calculer les IP


# Function Check_Softwares
# Description: try to check if all required software are installed
# Args: no args
function Check_Softwares() {
    qemu-system_x86_64
    openIPMI_lanserv
    sqlite3
}

# Function: Check_System
# Description: Check system requirements
# Args: no args
# Steps:
#   1: Check module vhost-net
#   2: Check perms on /dev/net/tun, /dev/vhost-net and /dev/kvm
#   3: Set cap_net_admin on qemu-system_x86_64
function Check_System() {
    if [ "$(sudo modinfo vhost-net -F intree)" != "Y" ]; then
        sudo modprobe vhost vhost-net
    fi
    
    ls -l /dev/net/tun | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/net/tun
    fi

    ls -l /dev/vhost-net | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/vhost-net
    fi

    ls -l /dev/kvm | cut -d\  -f1 | grep 'crw-rw-rw-' > /dev/null
    if [ $? -ne 0 ]; then
        sudo chmod 0666 /dev/kvm
    fi

    sudo getcap /usr/bin/qemu-system-x86_64 | grep cap_net_admin+ep > /dev/null
    if [ $? -ne 0 ]; then
        sudo setcap cap_net_admin+ep /usr/bin/qemu-system-x86_64
    fi
    
    # On a besoin de voir comment faire dans sudo pour que ça fonctionne
    #if [ $(cat /proc/sys/net/ipv4/ip_forward) -eq 0 ]; then
        #sudo echo 1 > /proc/sys/net/ipv4/ip_forward
    #fi
    
    modinfo openvswitch 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then
        sudo modprobe openvswitch
        [ -d /var/run/openvswitch ] || sudo mkdir /var/run/openvswitch
    fi
}

# Function: Set_Bridge_Brctl
# Description: Set bridges using brctl
# Args:
#     $1: bridge name
function Set_Bridge_Brctl() {
    ip address show $1 2> /dev/null 1> /dev/null
    if [ $? -ne 0 ]; then
        sudo ip link add $1 type bridge
        sudo ip link set dev $1 up
    fi
}

# function: Set_Bridge_Ovs
# Description: Create bridge using openvswitch
# Args:
#    $1: Bridge name
function Set_Bridge_Ovs() {
 if [ "$(sudo ovs-vsctl list-br | grep $1)" == "" ]; then
  sudo ovs-vsctl add-br $1
  sleep 0.1
  sudo ip link set dev $1 up
 fi
}

# function: Set_Bridge_Nmcli
# Description: create bridge using nmcli
# Args:
#    $1: Bridge name
function Set_Bridge_Nmcli() {
 nmcli dev show swvpl-main 2>&1 > /dev/null
 if [ $? -ne 0 ]; then
  nmcli dev con add save yes type bridge ifname $1
  nmcli con mod bridge-$1 connection.id $1
  nmcli dev set $1 autoconnect yes managed yes 
  nmcli dev connect $1
  nmcli dev reapply $1
 fi
}

# Function Check_MEM
# Description: Check if MEM and MAXMEM
# if MAXMEM is undefined, calculate MEM * 2
# Args:
#   $1: $MEM
#   $2: $MAXMEM
function Check_MEM() {
 if [ "$1" ]; then
  if [ "$2" ]; then
   echo $2
  else
   MAXMEM=$(( $1 * 2 ))
   MAXSYS=$(( $(grep "MemTotal: " /proc/meminfo  | awk '{print $2}' ) / 1024 / 1024 ))
   if [ $MAXMEM -gt $MAXSYS ]; then $MAXMEM == $MAXSYS; fi
   echo $MAXMEM
  fi
 else
   return 0
 fi
}

# Function: Set_NetDev
# Description: Create tap interfaces
# Args:
#   $1: Bridge name
#   $2: Number of tap devices
#   $3: tapupdown file path
# Return an array of netdev declarations
function Set_NedDev() {
    for NETNUMBER in $(seq $(( ${#NETDEV[@]} + 1 )) $(( ${#NETDEV[@]} + $2 )) ); do
        NETDEV[$NETNUMBER]="-netdev type=tap,id=virtio-tap$NETNUMBER,script=$3/tapup-$1,downscript=$3/tapdown-$1,vhost=on -device virtio-net-pci,netdev=virtio-tap$NETNUMBER,mac=$(Set_MAC $NETNUMBER),id=drive-virtio-tap$NETNUMBER,csum=off,gso=off,guest_tso4=off,guest_tso6=off,guest_ecn=off"
done
}

# Function: Set_MAC
# Description: Calculate MAC Address
# Args:
#   $1: Vm Name
#   $2: network device number
function Set_MAC() {
        OUI="52:54:00"
        SUBMAC=Db_Set_MAC $DB_PATH $1 $2
        echo $OUI:${SUBMAC:0:2}:${SUBMAC:2:2}:${SUBMAC:4:2}
}

# Function: Set_IPMI
# Description: Create IPMI device, using OpenIPMI-lanserv 
# Args:
#   $1: Vm Name
#   $2: IPMI Template Path
#   $3: IPMI Address
#   $4: IPMI Port
function Set_IPMI() {
  if [ ! -f /etc/ipmi/$2.conf ]; then
    cp $2 /etc/ipmi/$1.conf
    sed -i "s/%%IPMIADDR%%/$3/" /etc/ipmi/$1.conf
    sed -i "s/%%IPMIPORT%%/$4/" /etc/ipmi/$1.conf
    sed -i "s/%%NAME%%/$1/g" /etc/ipmi/$1.conf
  fi
}

# Function : Check_Existing_VM
# Description: Check on DB if VM already exists
# Args:
#   $1: VM Name
function Check_Existing_VM() {
 Set_Db $VMMGR_DB_PATH
 Db_Get_VM_Config $VMMGR_DB_PATH $1
}

# Function: Custom_VM_Config
# Description: Customize VM Configuration
# Args:
#   $1: VM name
#   $2: VM config path
function Custom_VM_Config() {
    sed -i "s/%%NAME%%/$1/g" $2
}

# Function: Start_VM_From_Config
# Description: Start VM using VM Config file
# Args:
#   $1: VM Name
#   $2: VM config path
function Start_VM_From_Config() {
    source $2
    qemu-system-x86_64 $QEMU_TEMPLATE
}

# Function: Gen_New_IP
# Description: Generate a new IP
#
#
# ToDo: on doit générer une nouvelle ip, généralement c'est soit plutôt pour spice,telnet et qmp.
# donc en fonction de ipv6ou4 on a une routine.
# 1. on a besoin de déclarer un réseau au préalable (autre fonction). Ce réseau est $1
# basé sur $1: on calcule, le réseau, lastIP, et currentIP
# on calcule la nouvelle IP dispo et on la renseigne dans la db
# NOTE: comment on sait quelle ip n'est pas dispo, si elle est déjà utilisée comment on va la modifier?
#       Peut-on utiliser à chaque fois une ip différente? (pas de stockage dans la base?
#       Pour ipv6 ce sera plus simple pour une IP unique pou l'interface on peut s'appuyer sur l'adrresse mac
#

# Function: Set_Service_Listen
# Description: Set IP and Port for Spice
#
#
#
# NOTE: On ne génère aucune IP ici, on s'occupe juste de générer un PORT si besoin
# ToDo: 1. si $1 n'est pas une ip mais une interface:
    # Si l'interface existe:
        # on s'appuye sur la première ip de l'interface (en fonction de $IPMODE)
    # Si l'interface n'existe pas: erreur
    # Si on a une IP:
        # Si elle existe déjà:
            #on l'utilise tel
        # Sinon, on créé une interface TAP
            # Si $3 est le nom d'un bridge, on enslave tap au bridge
    # pour le PORT:
        # si $4 est un port:
            # on utilise ce port
        # Si $4 est "gen"
            # on regarde dans la base si on a pas déjà une association SPICE:PORT
                # si c'est le cas on l'utilise,
                # Sinon on génère un nouveau port, et on la stocke dans la db
    # on retourne l'association IP:PORT
    
    
    ### ou alors on gère pas la création du bridge,
    # on précise quoi?
    # on a besoin d'une IP
    # on a besoin de savoir quoi en faire:
            # ip existante
            # ip à créer sur une iface existante
            # créer un tap avec l'ip.
            # Créer un tap avec l'ip et l'ajouter au bridge.
            # donc: $1 IP ou iface
            # $2: IP mode: 4 or 6
            # $3: tap|bridge|tap2br
            
function Set_Service_Listen() {
    NET="-$2"
    if [ "$(Is_Valid_IP $1)" == "0" ]; then
        if [ "$(Is_Existing_IP $1)" == "0" ]; then
            echo $1
        else
            
            if [ "$IFACE" == "" ]; then
                # l'interface n'existe pas
            else
                # on a l'interface, on créé une ip
            fi
            case "$3" in
                "tap")
                    IFACE=$(ip -$2 -br address show type tun | grep $1 | head -1 | awk '{print $1}')
                    if [ "$IFACE" == "" ]; then
                        # on créé l'iface
                    else
                        #on retourne l'ip de l'iface
                    fi
                ;;
                "bridge")
                    if IFACE=$(ip -$2 -br address show type bridge | grep $1 | head -1 | awk '{print $1}')
                    if [ "$IFACE" == "" ]; then
                        # on créé le bridge
                    else
                        #on retourne la première ip du bridge
                    fi
                ;;
                "tap2br")
                    
                ;;
            esac
            #on doit créer l'ip
            # on doit donc savoir où on créé l'ip, sur une interface existante? un tap?
            # on a donc $2 qui nous renseigne le nom de l'interface.
                # si l'interface existe, on ajoute l'ip
                # si l'interface existe pas on créé un tap
                    #enfin, si $3 est spécifié et que c'est un bridge, on l'enslave
        fi
    else
        # c'est pas une ip, on a donc un bridge
        if [ "$(Is_Existing_Bridge  $1)" == "0" ]; then
            # bridge existant
        else
            # bridge à créer
        fi
    fi
}

function Is_Valid_IP() {
    NET="-4"
    [ "$IPMODE" == "ipv6" ] && NET="-6"
    ipcalc $NET $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

function Is_Existing_IP() {
    NET="-4"
    [ "$IPMODE" == "ipv6" ] && NET="-6"
    ip $NET -br address show | grep $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

function Is_Existing_Bridge() {
    ip -br address show type bridge $1 2>/dev/null 1>/dev/null
    if [ $? -eq 0 ]; then 
        echo "0"
    else
        echo "1"
    fi
}

# Function: Set_New_Port
# Description: Get Port or generate new one
#   $1: Vm Name
#   $2: Type [spice|telnet|qmp|vnc]
#   $3: min port
#   $4: max port
function Set_New_Port() {
    EXISTS=$(Db_Get_IPPORT $VMMGR_DB_PATH $1 $2)
    if ["$EXISTS" == "" ]; then
        for PORT in $(seq $3 $4); do
            EXISTS=$(Db_Search_Port $VMMGR_DB_PATH $1 $PORT)
            if [ "$EXISTS" != "" ]; then break; fi
        done
    fi
    echo $EXISTS | cut -d\|  -f2
}


# Function: Get_Next_IPv4
# Description: Generate new IP from a pool
# Args:
#   $1: Network
# Steps:
#   1) extract Network values
#   2) get IP, convert in Hex value for operations
#   3) Calculate next IP
#   4) Check if we are not out of pool
function Get_Next_IPv4() {
    IFS=\| read -r IPNETWORK IPPREFIX MIN MAX LAST BR <<< $(echo "$1")

    IFS=. read -r i1 i2 i3 i4 <<< $(ipcalc --network $IPNETWORK --prefix $IPPREFIX --info | grep Network | awk '{print $2}' | cut -d\/ -f 1)
    printf -v Network '%02x' $i1 $i2 $i3 $i4
    
    printf -v LAST '%02x' $LAST
    FirstIP=$(echo "obase=16;ibase=16; ${Network^^} + ${LAST^^}" | bc)
    NextIP=$(echo "obase=16;ibase=16; ${FirstIP^^} + 1" | bc)
    printf -v NextIP '%08x' 0x$NextIP
    NextIP=${NextIP^^}
    
    printf -v MAX '%02x' $MAX
    MaxIP=$(echo "obase=16;ibase=16;${Network^^} + ${MAX^^}" | bc)
    printf -v MaxIP '%08x' 0x$MaxIP
    MaxIP=${MaxIP^^}
    
 
    if [ $(echo "obase=10;ibase=16; ${NextIP^^}" | bc) -le $(echo "obase=10;ibase=16; ${MaxIP^^}" | bc) ]; then
        echo $(echo "ibase=16;obase=A;${NextIP:0:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:2:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:4:2}" | bc).$(echo "ibase=16;obase=A;${NextIP:6:2}" | bc)
    fi
}

# Function: Get_Next_IPv6
# Description: Generate new IP from a pool
# Args:
#   $1: Network
# Steps:
#   1) extract Network values
#   2) get full lengh IPv6
#   3) Calculate next IP
#   4) Check if we are not out of pool (I know, useless...)
function Get_Next_IPv6() {

    IFS=\| read -r IPNETWORK IPPREFIX MIN MAX LAST BR <<< $(echo "$1")
    
    Network=$(ipcalc -6 --network $IPNETWORK/$IPPREFIX  --info | grep "Full Network" | awk '{print $3}' | cut -d/  -f1 | tr -d : )
    FirstIP=$(echo "obase=16;ibase=16; ${Network^^} + ${LAST^^}" | bc)
    NextIP=$(echo "obase=16;ibase=16; ${FirstIP^^} + 1" | bc)

    MaxIP=$(echo "obase=16;ibase=16;${Network^^} + ${MAX^^}" | bc)
    if [ "$(echo "obase=16;ibase=16; ${MaxIP^^} > ${NextIP^^}" | bc)" == "1" ]; then
        echo ${NextIP:0:4}:${NextIP:4:4}:${NextIP:8:4}:${NextIP:12:4}:${NextIP:16:4}:${NextIP:20:4}:${NextIP:24:4}:${NextIP:28:4}
    fi
}

# Function: Set_New_IP
# Description: Get IP or generate new one
#   $1: Vm Name
#   $2: Type [spice|telnet|qmp|vnc]
#   $3: Network
function Set_New_IP() {
    EXISTS=$(Db_Get_IPPORT $VMMGR_DB_PATH $1 $2)
    if ["$EXISTS" == "" ]; then
        1. on get network, si on a pas, on retourne rien
        select * from NETWORKS where IFACE='$3'
        if [ "$EXISTS" != "" ]; then
            #on get new next ip
            
            EXISTS=$(Get_Next_IPv4 $EXISTS)
            EXISTS=$(Get_Next_IPv6 $EXISTS)
        fi
    fi
    echo $EXISTS | cut -d\|  -f1
    
}
