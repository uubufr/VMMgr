#! /bin/bash
#
# script name: VMMgr_Disks
# autor: Sylvain Girod ( uubu at gmx dot fr )
# version: 0.04
# description: Disks management
#
# Functions:
# Set_Disk_Threads: Create threads objects
# Set_Virtio_Disks: Take the list of disks, then génerate -object and -device
# Set_Disks: Get disk list, check if they already exists and if not, create it
# Set_Pci_Bridge: Create Pci_Bridge for Virtio Disks

# Function: Set_Disk_Threads
# Description: Create threads objects
# Args:
#   $1: number of threads
function Set_Disk_Threads() {
    THREADS=""
    for DTHREAD in $(seq 1 $1); do
        THREADS="$THREADS -object iothread,id=iothread$DTHREAD"
    done
    echo $THREADS
}

# Function: Set_Pci_Bridge
# Description: Create Pci_Bridge for Virtio Disks
# Args:
#   $1: How many bridge?
function Set_Pci_Bridge() {
    PCIs=""
    for PCI in $(seq 1 $1 ); do
        PCIs="$PCIs -device pci-bridge,id=pci.$PCI,chassis_nr=1"
    done
    echo $PCIs
}

# Function: Set_Disks
# Description: Get disk list, check if they already exists and if not, create it
# Args:
#   $1: Vm Name
function Set_Disks() {
    DisksList=""
    DNUM=0
    CPATH=""
    for ARRAYNUM in $(seq 1 ${#Virtio_Disk[@]}); do
        read -r DNUMBER DSIZE DPATH <<< $(echo "${Virtio_Disk[$ARRAYNUM]}")
        if [ "$DNUMBER" == "" ]; then continue; fi
        case "${DPATH%%:*}" in
            "order")
                ORDER="order"
                ;;
            "share")
                ORDER="share"
                ;;
            *)
                ORDER="share"
                ;;
        esac
        
        CounterPATH="1"
        for drive in $(seq 1 $DNUMBER); do
            DNUM=$(( DNUM + 1 ))
            
            ### First, we need to find if disk exists:
            EXISTS="Qemu-Virtio-Disk_qcow2_$DSIZE-$DNUM-$NAME"
            DFOUND=0
            OldCounter=$CounterPATH
            for EPATH in $( echo $DPATH | tr : \  ); do
                [ -d $EPATH ] || mkdir -p $EPATH
                if [ -r "$EPATH/$EXISTS" ]; then
                    DFOUND=1; break;
                else
                   if [ "$ORDER" == "share" ]; then
                    CounterPATH=$(( $CounterPATH + 1 ))
                   fi
                fi
            done
            if [ "$DFOUND" == 1 ]; then
                CPATH=$EPATH
                DisksList="$DisksList|$EPATH/$EXISTS"
            else
                CounterPATH=$OldCounter
                case "$ORDER" in
                    "share")
                        DPATH=${DPATH#share:}
                            CPATH=$( echo $DPATH | cut -d: -f $CounterPATH)
                            if [ "$CPATH" == "" ]; then
                                CounterPATH=1
                                CPATH=$( echo $DPATH | cut -d: -f $CounterPATH)
                            fi
                            CounterPATH=$(( $CounterPATH + 1 ))
                        ;;
                    "order")
                        DPATH=${DPATH#order:}
                        # Here, we need to check if we have enough space on the disk, if not, we check next path:
                        CPATH=$( echo $DPATH | cut -d: -f $CounterPATH)
                        IAVAIL=$(echo "$(df --block-size=1k --sync --output=iavail $CPATH | tail -1)K" | numfmt --from=iec )
                        AVAIL=$(echo "$(df --block-size=1k --sync --output=avail $CPATH | tail -1)K" | numfmt --from=iec )
                        OSIZE=$(echo 8G | numfmt --from=iec)
                        AVAIL=$(( $AVAIL - $OSIZE ))
                        
                        # Not enough space left on the device
                        while [ $AVAIL -le "0" ]; do
                            CounterPATH=$(( $CounterPATH + 1 ))
                            CPATH=$( echo $DPATH | cut -d: -f $CounterPATH)
                            if [ "$CPATH" == "" ]; then                     # end of path list, so no space left anywhere, error
                                break;
                            else                                            # Checking next path
                                IAVAIL=$(echo "$(df --block-size=1k --sync --output=iavail $CPATH | tail -1)K" | numfmt --from=iec )
                                AVAIL=$(echo "$(df --block-size=1k --sync --output=avail $CPATH | tail -1)K" | numfmt --from=iec )
                                OSIZE=$(echo 8G | numfmt --from=iec)
                                AVAIL=$(( $AVAIL - $OSIZE ))
                            fi
                        done
                        ;;
                esac
                qemu-img create -f qcow2 -o cluster_size=32k "$CPATH/Qemu-Virtio-Disk_qcow2_$DSIZE-$DNUM-$NAME" $DSIZE 2>/dev/null 1>/dev/null
            fi
            DisksList="$DisksList|$CPATH/Qemu-Virtio-Disk_qcow2_$DSIZE-$DNUM-$NAME"
        done
    done
    echo ${DisksList#|}
}

# Function: Set_Virtio_Disks
# Description: Déclare iothreads, pci-bridges, and drives
# Args:
#   $1: Vm Name
#   $2: Num Threads
#   $3: DiskLists
function Set_Virtio_Disks() {
    IOTHREADS=$(Set_Disk_Threads $2)
    COUNT=0;PCOUNT=0
    PCIBRIDGE=1
    declare -i THREAD=1
    for DISK in $(echo $3 | tr \| \  ); do
        COUNT=$(( $COUNT + 1 ))
        PCOUNT=$(( $PCOUNT + 1 ))
        if [ $PCOUNT -gt 31 ]; then
            PCIBRIDGE=$(( $PCIBRIDGE + 1 ))
            PCOUNT=1
        fi
        DRIVES="$DRIVES-drive file=$DISK,if=none,format=qcow2,id=virtio-disk$COUNT,cache=directsync,aio=native,werror=enospc,rerror=report -device virtio-blk-pci,iothread=iothread$THREAD,ioeventfd=on,event_idx=on,scsi=off,config-wce=off,drive=virtio-disk$COUNT,bus=pci.$PCIBRIDGE,addr=0x$(echo "ibase=10;obase=16;$PCOUNT" | bc).0x0 "
        THREAD=$(( $THREAD + 1 )); [ $THREAD -gt $2 ] && THREAD=1
    done
    PCIs=$(Set_Pci_Bridge $PCIBRIDGE)
    echo $IOTHREADS $PCIs $DRIVES
}
