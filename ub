QEMU.1(1)                                                                                                                                                                                                                     QEMU.1(1)

[1mNAME[0m
       qemu-doc - QEMU version 3.1.1 User Documentation

[1mSYNOPSIS[0m
       [1mqemu-system-i386 [22m[[4moptions[24m] [[4mdisk_image[24m]

[1mDESCRIPTION[0m
       The QEMU PC System emulator simulates the following peripherals:

       -   i440FX host PCI bridge and PIIX3 PCI to ISA bridge

       -   Cirrus CLGD 5446 PCI VGA card or dummy VGA card with Bochs VESA extensions (hardware level, including all non standard modes).

       -   PS/2 mouse and keyboard

       -   2 PCI IDE interfaces with hard disk and CD-ROM support

       -   Floppy disk

       -   PCI and ISA network adapters

       -   Serial ports

       -   IPMI BMC, either and internal or external one

       -   Creative SoundBlaster 16 sound card

       -   ENSONIQ AudioPCI ES1370 sound card

       -   Intel 82801AA AC97 Audio compatible sound card

       -   Intel HD Audio Controller and HDA codec

       -   Adlib (OPL2) - Yamaha YM3812 compatible chip

       -   Gravis Ultrasound GF1 sound card

       -   CS4231A compatible sound card

       -   PCI UHCI, OHCI, EHCI or XHCI USB controller and a virtual USB-1.1 hub.

       SMP is supported with up to 255 CPUs.

       QEMU uses the PC BIOS from the Seabios project and the Plex86/Bochs LGPL VGA BIOS.

       QEMU uses YM3812 emulation by Tatsuyuki Satoh.

       QEMU uses GUS emulation (GUSEMU32 <[1mhttp://www.deinmeister.de/gusemu/[22m>) by Tibor "TS" Sch√ºtz.

       Note that, by default, GUS shares [1mIRQ[22m(7) with parallel ports and so QEMU must be told to not have parallel ports to have working GUS.

               qemu-system-i386 dos.img -soundhw gus -parallel none

       Alternatively:

               qemu-system-i386 dos.img -device gus,irq=5

       Or some other unclaimed IRQ.

       CS4231A is the chip used in Windows Sound System and GUSMAX products

[1mOPTIONS[0m
       [4mdisk_image[24m is a raw hard disk image for IDE hard disk 0. Some targets do not need a disk image.

       [4mStandard[24m [4moptions[0m

       [1m-h  [22mDisplay help and exit

       [1m-version[0m
           Display version information and exit

       [1m-machine [type=][4m[22mname[24m[1m[,prop=[4m[22mvalue[24m[1m[,...]][0m
           Select the emulated machine by [4mname[24m. Use "-machine help" to list available machines.

           For architectures which aim to support live migration compatibility across releases, each release will introduce a new versioned machine type. For example, the 2.8.0 release introduced machine types "pc-i440fx-2.8" and
           "pc-q35-2.8" for the x86_64/i686 architectures.

           To allow live migration of guests from QEMU version 2.8.0, to QEMU version 2.9.0, the 2.9.0 version must support the "pc-i440fx-2.8" and "pc-q35-2.8" machines too. To allow users live migrating VMs to skip multiple
           intermediate releases when upgrading, new releases of QEMU will support machine types from many previous versions.

           Supported machine properties are:

           [1maccel=[4m[22maccels1[24m[1m[:[4m[22maccels2[24m[1m[:...]][0m
               This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is
               used if the previous one fails to initialize.

           [1mkernel_irqchip=on|off[0m
               Controls in-kernel irqchip support for the chosen accelerator when available.

           [1mgfx_passthru=on|off[0m
               Enables IGD GFX passthrough support for the chosen machine when available.

           [1mvmport=on|off|auto[0m
               Enables emulation of VMWare IO port, for vmmouse etc. auto says to select the value based on accel. For accel=xen the default is off otherwise the default is on.

           [1mkvm_shadow_mem=size[0m
               Defines the size of the KVM shadow MMU.

           [1mdump-guest-core=on|off[0m
               Include guest memory in a core dump. The default is on.

           [1mmem-merge=on|off[0m
               Enables or disables memory merge support. This feature, when supported by the host, de-duplicates identical memory pages among VMs instances (enabled by default).

           [1maes-key-wrap=on|off[0m
               Enables or disables AES key wrapping support on s390-ccw hosts. This feature controls whether AES wrapping keys will be created to allow execution of AES cryptographic functions.  The default is on.

           [1mdea-key-wrap=on|off[0m
               Enables or disables DEA key wrapping support on s390-ccw hosts. This feature controls whether DEA wrapping keys will be created to allow execution of DEA cryptographic functions.  The default is on.

           [1mnvdimm=on|off[0m
               Enables or disables NVDIMM support. The default is off.

           [1menforce-config-section=on|off[0m
               If [1menforce-config-section [22mis set to [4mon[24m, force migration code to send configuration section even if the machine-type sets the [1mmigration.send-configuration [22mproperty to [4moff[24m.  NOTE: this parameter is deprecated. Please
               use [1m-global migration.send-configuration[22m=[4mon|off[24m instead.

           [1mmemory-encryption=[0m
               Memory encryption object to use. The default is none.

       [1m-cpu [4m[22mmodel[0m
           Select CPU model ("-cpu help" for list and additional feature selection)

       [1m-accel [4m[22mname[24m[1m[,prop=[4m[22mvalue[24m[1m[,...]][0m
           This is used to enable an accelerator. Depending on the target architecture, kvm, xen, hax, hvf, whpx or tcg can be available. By default, tcg is used. If there is more than one accelerator specified, the next one is
           used if the previous one fails to initialize.

           [1mthread=single|multi[0m
               Controls number of TCG threads. When the TCG is multi-threaded there will be one thread per vCPU therefor taking advantage of additional host cores. The default is to enable multi-threading where both the back-end
               and front-ends support it and no incompatible TCG features have been enabled (e.g. icount/replay).

       [1m-smp [cpus=][4m[22mn[24m[1m[,cores=[4m[22mcores[24m[1m][,threads=[4m[22mthreads[24m[1m][,sockets=[4m[22msockets[24m[1m][,maxcpus=[4m[22mmaxcpus[24m[1m][0m
           Simulate an SMP system with [4mn[24m CPUs. On the PC target, up to 255 CPUs are supported. On Sparc32 target, Linux limits the number of usable CPUs to 4.  For the PC target, the number of [4mcores[24m per socket, the number of
           [4mthreads[24m per cores and the total number of [4msockets[24m can be specified. Missing values will be computed. If any on the three values is given, the total number of CPUs [4mn[24m can be omitted. [4mmaxcpus[24m specifies the maximum number of
           hotpluggable CPUs.

       [1m-numa node[,mem=[4m[22msize[24m[1m][,cpus=[4m[22mfirstcpu[24m[1m[-[4m[22mlastcpu[24m[1m]][,nodeid=[4m[22mnode[24m[1m][0m
       [1m-numa node[,memdev=[4m[22mid[24m[1m][,cpus=[4m[22mfirstcpu[24m[1m[-[4m[22mlastcpu[24m[1m]][,nodeid=[4m[22mnode[24m[1m][0m
       [1m-numa dist,src=[4m[22msource[24m[1m,dst=[4m[22mdestination[24m[1m,val=[4m[22mdistance[0m
       [1m-numa cpu,node-id=[4m[22mnode[24m[1m[,socket-id=[4m[22mx[24m[1m][,core-id=[4m[22my[24m[1m][,thread-id=[4m[22mz[24m[1m][0m
           Define a NUMA node and assign RAM and VCPUs to it.  Set the NUMA distance from a source node to a destination node.

           Legacy VCPU assignment uses [1mcpus [22moption where [4mfirstcpu[24m and [4mlastcpu[24m are CPU indexes. Each [1mcpus [22moption represent a contiguous range of CPU indexes (or a single VCPU if [4mlastcpu[24m is omitted). A non-contiguous set of VCPUs can
           be represented by providing multiple [1mcpus [22moptions. If [1mcpus [22mis omitted on all nodes, VCPUs are automatically split between them.

           For example, the following option assigns VCPUs 0, 1, 2 and 5 to a NUMA node:

                   -numa node,cpus=0-2,cpus=5

           [1mcpu [22moption is a new alternative to [1mcpus [22moption which uses [1msocket-id|core-id|thread-id [22mproperties to assign CPU objects to a [4mnode[24m using topology layout properties of CPU.  The set of properties is machine specific, and
           depends on used machine type/[1msmp [22moptions. It could be queried with [1mhotpluggable-cpus [22mmonitor command.  [1mnode-id [22mproperty specifies [4mnode[24m to which CPU object will be assigned, it's required for [4mnode[24m to be declared with [1mnode[0m
           option before it's used with [1mcpu [22moption.

           For example:

                   -M pc \
                   -smp 1,sockets=2,maxcpus=2 \
                   -numa node,nodeid=0 -numa node,nodeid=1 \
                   -numa cpu,node-id=0,socket-id=0 -numa cpu,node-id=1,socket-id=1

           [1mmem [22massigns a given RAM amount to a node. [1mmemdev [22massigns RAM from a given memory backend device to a node. If [1mmem [22mand [1mmemdev [22mare omitted in all nodes, RAM is split equally between them.

           [1mmem [22mand [1mmemdev [22mare mutually exclusive. Furthermore, if one node uses [1mmemdev[22m, all of them have to use it.

           [4msource[24m and [4mdestination[24m are NUMA node IDs.  [4mdistance[24m is the NUMA distance from [4msource[24m to [4mdestination[24m.  The distance from a node to itself is always 10. If any pair of nodes is given a distance, then all pairs must be
           given distances. Although, when distances are only given in one direction for each pair of nodes, then the distances in the opposite directions are assumed to be the same. If, however, an asymmetrical pair of distances
           is given for even one node pair, then all node pairs must be provided distance values for both directions, even when they are symmetrical. When a node is unreachable from another node, set the pair's distance to 255.

           Note that the -[1mnuma [22moption doesn't allocate any of the specified resources, it just assigns existing resources to NUMA nodes. This means that one still has to use the [1m-m[22m, [1m-smp [22moptions to allocate RAM and VCPUs
           respectively.

       [1m-add-fd fd=[4m[22mfd[24m[1m,set=[4m[22mset[24m[1m[,opaque=[4m[22mopaque[24m[1m][0m
           Add a file descriptor to an fd set.  Valid options are:

           [1mfd=[4m[22mfd[0m
               This option defines the file descriptor of which a duplicate is added to fd set.  The file descriptor cannot be stdin, stdout, or stderr.

           [1mset=[4m[22mset[0m
               This option defines the ID of the fd set to add the file descriptor to.

           [1mopaque=[4m[22mopaque[0m
               This option defines a free-form string that can be used to describe [4mfd[24m.

           You can open an image using pre-opened file descriptors from an fd set:

                   qemu-system-i386
                   -add-fd fd=3,set=2,opaque="rdwr:/path/to/file"
                   -add-fd fd=4,set=2,opaque="rdonly:/path/to/file"
                   -drive file=/dev/fdset/2,index=0,media=disk

       [1m-set [4m[22mgroup[24m[1m.[4m[22mid[24m[1m.[4m[22marg[24m[1m=[4m[22mvalue[0m
           Set parameter [4marg[24m for item [4mid[24m of type [4mgroup[0m

       [1m-global [4m[22mdriver[24m[1m.[4m[22mprop[24m[1m=[4m[22mvalue[0m
       [1m-global driver=[4m[22mdriver[24m[1m,property=[4m[22mproperty[24m[1m,value=[4m[22mvalue[0m
           Set default value of [4mdriver[24m's property [4mprop[24m to [4mvalue[24m, e.g.:

                   qemu-system-i386 -global ide-hd.physical_block_size=4096 disk-image.img

           In particular, you can use this to set driver properties for devices which are created automatically by the machine model. To create a device which is not created automatically and set properties on it, use -[1mdevice[22m.

           -global [4mdriver[24m.[4mprop[24m=[4mvalue[24m is shorthand for -global driver=[4mdriver[24m,property=[4mprop[24m,value=[4mvalue[24m.  The longhand syntax works even when [4mdriver[24m contains a dot.

       [1m-boot [order=[4m[22mdrives[24m[1m][,once=[4m[22mdrives[24m[1m][,menu=on|off][,splash=[4m[22msp_name[24m[1m][,splash-time=[4m[22msp_time[24m[1m][,reboot-timeout=[4m[22mrb_timeout[24m[1m][,strict=on|off][0m
           Specify boot order [4mdrives[24m as a string of drive letters. Valid drive letters depend on the target architecture. The x86 PC uses: a, b (floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p (Etherboot from network
           adapter 1-4), hard disk boot is the default. To apply a particular boot order only on the first startup, specify it via [1monce[22m. Note that the [1morder [22mor [1monce [22mparameter should not be used together with the [1mbootindex [22mproperty
           of devices, since the firmware implementations normally do not support both at the same time.

           Interactive boot menus/prompts can be enabled via [1mmenu=on [22mas far as firmware/BIOS supports them. The default is non-interactive boot.

           A splash picture could be passed to bios, enabling user to show it as logo, when option splash=[4msp_name[24m is given and menu=on, If firmware/BIOS supports them. Currently Seabios for X86 system support it.  limitation: The
           splash file could be a jpeg file or a BMP file in 24 BPP format(true color). The resolution should be supported by the SVGA mode, so the recommended is 320x240, 640x480, 800x640.

           A timeout could be passed to bios, guest will pause for [4mrb_timeout[24m ms when boot failed, then reboot. If [4mrb_timeout[24m is '-1', guest will not reboot, qemu passes '-1' to bios by default. Currently Seabios for X86 system
           support it.

           Do strict boot via [1mstrict=on [22mas far as firmware/BIOS supports it. This only effects when boot priority is changed by bootindex options. The default is non-strict boot.

                   # try to boot from network first, then from hard disk
                   qemu-system-i386 -boot order=nc
                   # boot from CD-ROM first, switch back to default order after reboot
                   qemu-system-i386 -boot once=d
                   # boot with a splash picture for 5 seconds.
                   qemu-system-i386 -boot menu=on,splash=/root/boot.bmp,splash-time=5000

           Note: The legacy format '-boot [4mdrives[24m' is still supported but its use is discouraged as it may be removed from future versions.

       [1m-m [size=][4m[22mmegs[24m[1m[,slots=n,maxmem=size][0m
           Sets guest startup RAM size to [4mmegs[24m megabytes. Default is 128 MiB.  Optionally, a suffix of "M" or "G" can be used to signify a value in megabytes or gigabytes respectively. Optional pair [4mslots[24m, [4mmaxmem[24m could be used to
           set amount of hotpluggable memory slots and maximum amount of memory. Note that [4mmaxmem[24m must be aligned to the page size.

           For example, the following command-line sets the guest startup RAM size to 1GB, creates 3 slots to hotplug additional memory and sets the maximum memory the guest can reach to 4GB:

                   qemu-system-x86_64 -m 1G,slots=3,maxmem=4G

           If [4mslots[24m and [4mmaxmem[24m are not specified, memory hotplug won't be enabled and the guest startup RAM will never increase.

       [1m-mem-path [4m[22mpath[0m
           Allocate guest RAM from a temporarily created file in [4mpath[24m.

       [1m-mem-prealloc[0m
           Preallocate memory when using -mem-path.

       [1m-k [4m[22mlanguage[0m
           Use keyboard layout [4mlanguage[24m (for example "fr" for French). This option is only needed where it is not easy to get raw PC keycodes (e.g. on Macs, with some X11 servers or with a VNC or curses display). You don't normally
           need to use it on PC/Linux or PC/Windows hosts.

           The available layouts are:

                   ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv
                   da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th
                   de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr

           The default is "en-us".

       [1m-audio-help[0m
           Will show the audio subsystem help: list of drivers, tunable parameters.

       [1m-soundhw [4m[22mcard1[24m[1m[,[4m[22mcard2[24m[1m,...] or -soundhw all[0m
           Enable audio and selected sound hardware. Use 'help' to print all available sound hardware.

                   qemu-system-i386 -soundhw sb16,adlib disk.img
                   qemu-system-i386 -soundhw es1370 disk.img
                   qemu-system-i386 -soundhw ac97 disk.img
                   qemu-system-i386 -soundhw hda disk.img
                   qemu-system-i386 -soundhw all disk.img
                   qemu-system-i386 -soundhw help

           Note that Linux's i810_audio OSS kernel (for AC97) module might require manually specifying clocking.

                   modprobe i810_audio clocking=48000

       [1m-device [4m[22mdriver[24m[1m[,[4m[22mprop[24m[1m[=[4m[22mvalue[24m[1m][,...]][0m
           Add device [4mdriver[24m.  [4mprop[24m=[4mvalue[24m sets driver properties.  Valid properties depend on the driver.  To get help on possible drivers and properties, use "-device help" and "-device [4mdriver,help"[24m.

           Some drivers are:

       [1m-device ipmi-bmc-sim,id=[4m[22mid[24m[1m[,slave_addr=[4m[22mval[24m[1m][,sdrfile=[4m[22mfile[24m[1m][,furareasize=[4m[22mval[24m[1m][,furdatafile=[4m[22mfile[24m[1m][0m
           Add an IPMI BMC.  This is a simulation of a hardware management interface processor that normally sits on a system.  It provides a watchdog and the ability to reset and power control the system.  You need to connect this
           to an IPMI interface to make it useful

           The IPMI slave address to use for the BMC.  The default is 0x20.  This address is the BMC's address on the I2C network of management controllers.  If you don't know what this means, it is safe to ignore it.

           [1mbmc=[4m[22mid[0m
               The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.

           [1mslave_addr=[4m[22mval[0m
               Define slave address to use for the BMC.  The default is 0x20.

           [1msdrfile=[4m[22mfile[0m
               file containing raw Sensor Data Records (SDR) data. The default is none.

           [1mfruareasize=[4m[22mval[0m
               size of a Field Replaceable Unit (FRU) area.  The default is 1024.

           [1mfrudatafile=[4m[22mfile[0m
               file containing raw Field Replaceable Unit (FRU) inventory data. The default is none.

       [1m-device ipmi-bmc-extern,id=[4m[22mid[24m[1m,chardev=[4m[22mid[24m[1m[,slave_addr=[4m[22mval[24m[1m][0m
           Add a connection to an external IPMI BMC simulator.  Instead of locally emulating the BMC like the above item, instead connect to an external entity that provides the IPMI services.

           A connection is made to an external BMC simulator.  If you do this, it is strongly recommended that you use the "reconnect=" chardev option to reconnect to the simulator if the connection is lost.  Note that if this is
           not used carefully, it can be a security issue, as the interface has the ability to send resets, NMIs, and power off the VM.  It's best if QEMU makes a connection to an external simulator running on a secure port on
           localhost, so neither the simulator nor QEMU is exposed to any outside network.

           See the "lanserv/README.vm" file in the OpenIPMI library for more details on the external interface.

       [1m-device isa-ipmi-kcs,bmc=[4m[22mid[24m[1m[,ioport=[4m[22mval[24m[1m][,irq=[4m[22mval[24m[1m][0m
           Add a KCS IPMI interafce on the ISA bus.  This also adds a corresponding ACPI and SMBIOS entries, if appropriate.

           [1mbmc=[4m[22mid[0m
               The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.

           [1mioport=[4m[22mval[0m
               Define the I/O address of the interface.  The default is 0xca0 for KCS.

           [1mirq=[4m[22mval[0m
               Define the interrupt to use.  The default is 5.  To disable interrupts, set this to 0.

       [1m-device isa-ipmi-bt,bmc=[4m[22mid[24m[1m[,ioport=[4m[22mval[24m[1m][,irq=[4m[22mval[24m[1m][0m
           Like the KCS interface, but defines a BT interface.  The default port is 0xe4 and the default interrupt is 5.

       [1m-name [4m[22mname[0m
           Sets the [4mname[24m of the guest.  This name will be displayed in the SDL window caption.  The [4mname[24m will also be used for the VNC server.  Also optionally set the top visible process name in Linux.  Naming of individual
           threads can also be enabled on Linux to aid debugging.

       [1m-uuid [4m[22muuid[0m
           Set system UUID.

       [4mBlock[24m [4mdevice[24m [4moptions[0m

       [1m-fda [4m[22mfile[0m
       [1m-fdb [4m[22mfile[0m
           Use [4mfile[24m as floppy disk 0/1 image.

       [1m-hda [4m[22mfile[0m
       [1m-hdb [4m[22mfile[0m
       [1m-hdc [4m[22mfile[0m
       [1m-hdd [4m[22mfile[0m
           Use [4mfile[24m as hard disk 0, 1, 2 or 3 image.

       [1m-cdrom [4m[22mfile[0m
           Use [4mfile[24m as CD-ROM image (you cannot use [1m-hdc [22mand [1m-cdrom [22mat the same time). You can use the host CD-ROM by using [4m/dev/cdrom[24m as filename.

       [1m-blockdev [4m[22moption[24m[1m[,[4m[22moption[24m[1m[,[4m[22moption[24m[1m[,...]]][0m
           Define a new block driver node. Some of the options apply to all block drivers, other options are only accepted for a specific block driver. See below for a list of generic options and options for the most common block
           drivers.

           Options that expect a reference to another node (e.g. "file") can be given in two ways. Either you specify the node name of an already existing node (file=[4mnode-name[24m), or you define a new node inline, adding options for
           the referenced node after a dot (file.filename=[4mpath[24m,file.aio=native).

           A block driver node created with [1m-blockdev [22mcan be used for a guest device by specifying its node name for the "drive" property in a [1m-device [22margument that defines a block device.

           [1mValid options for any block driver node:[0m
               "driver"
                   Specifies the block driver to use for the given node.

               "node-name"
                   This defines the name of the block driver node by which it will be referenced later. The name must be unique, i.e. it must not match the name of a different block driver node, or (if you use [1m-drive [22mas well) the
                   ID of a drive.

                   If no node name is specified, it is automatically generated. The generated node name is not intended to be predictable and changes between QEMU invocations.  For the top level, an explicit node name must be
                   specified.

               "read-only"
                   Open the node read-only. Guest write attempts will fail.

               "cache.direct"
                   The host page cache can be avoided with [1mcache.direct=on[22m. This will attempt to do disk IO directly to the guest's memory. QEMU may still perform an internal copy of the data.

               "cache.no-flush"
                   In case you don't care about data integrity over host failures, you can use [1mcache.no-flush=on[22m. This option tells QEMU that it never needs to write any data to the disk but can instead keep things in cache. If
                   anything goes wrong, like your host losing power, the disk storage getting disconnected accidentally, etc. your image will most probably be rendered unusable.

               "discard=[4mdiscard[24m"
                   [4mdiscard[24m is one of "ignore" (or "off") or "unmap" (or "on") and controls whether "discard" (also known as "trim" or "unmap") requests are ignored or passed to the filesystem. Some machine types may not support
                   discard requests.

               "detect-zeroes=[4mdetect-zeroes[24m"
                   [4mdetect-zeroes[24m is "off", "on" or "unmap" and enables the automatic conversion of plain zero writes by the OS to driver specific optimized zero write commands. You may even choose "unmap" if [4mdiscard[24m is set to
                   "unmap" to allow a zero write to be converted to an "unmap" operation.

           [1mDriver-specific options for "file"[0m
               This is the protocol-level block driver for accessing regular files.

               "filename"
                   The path to the image file in the local filesystem

               "aio"
                   Specifies the AIO backend (threads/native, default: threads)

               "locking"
                   Specifies whether the image file is protected with Linux OFD / POSIX locks. The default is to use the Linux Open File Descriptor API if available, otherwise no lock is applied.  (auto/on/off, default: auto)

               Example:

                       -blockdev driver=file,node-name=disk,filename=disk.img

           [1mDriver-specific options for "raw"[0m
               This is the image format block driver for raw images. It is usually stacked on top of a protocol level block driver such as "file".

               "file"
                   Reference to or definition of the data source block driver node (e.g. a "file" driver node)

               Example 1:

                       -blockdev driver=file,node-name=disk_file,filename=disk.img
                       -blockdev driver=raw,node-name=disk,file=disk_file

               Example 2:

                       -blockdev driver=raw,node-name=disk,file.driver=file,file.filename=disk.img

           [1mDriver-specific options for "qcow2"[0m
               This is the image format block driver for qcow2 images. It is usually stacked on top of a protocol level block driver such as "file".

               "file"
                   Reference to or definition of the data source block driver node (e.g. a "file" driver node)

               "backing"
                   Reference to or definition of the backing file block device (default is taken from the image file). It is allowed to pass "null" here in order to disable the default backing file.

               "lazy-refcounts"
                   Whether to enable the lazy refcounts feature (on/off; default is taken from the image file)

               "cache-size"
                   The maximum total size of the L2 table and refcount block caches in bytes (default: the sum of l2-cache-size and refcount-cache-size)

               "l2-cache-size"
                   The maximum size of the L2 table cache in bytes (default: if cache-size is not specified - 32M on Linux platforms, and 8M on non-Linux platforms; otherwise, as large as possible within the cache-size, while
                   permitting the requested or the minimal refcount cache size)

               "refcount-cache-size"
                   The maximum size of the refcount block cache in bytes (default: 4 times the cluster size; or if cache-size is specified, the part of it which is not used for the L2 cache)

               "cache-clean-interval"
                   Clean unused entries in the L2 and refcount caches. The interval is in seconds.  The default value is 600 on supporting platforms, and 0 on other platforms.  Setting it to 0 disables this feature.

               "pass-discard-request"
                   Whether discard requests to the qcow2 device should be forwarded to the data source (on/off; default: on if discard=unmap is specified, off otherwise)

               "pass-discard-snapshot"
                   Whether discard requests for the data source should be issued when a snapshot operation (e.g. deleting a snapshot) frees clusters in the qcow2 file (on/off; default: on)

               "pass-discard-other"
                   Whether discard requests for the data source should be issued on other occasions where a cluster gets freed (on/off; default: off)

               "overlap-check"
                   Which overlap checks to perform for writes to the image (none/constant/cached/all; default: cached). For details or finer granularity control refer to the QAPI documentation of "blockdev-add".

               Example 1:

                       -blockdev driver=file,node-name=my_file,filename=/tmp/disk.qcow2
                       -blockdev driver=qcow2,node-name=hda,file=my_file,overlap-check=none,cache-size=16777216

               Example 2:

                       -blockdev driver=qcow2,node-name=disk,file.driver=http,file.filename=http://example.com/image.qcow2

           [1mDriver-specific options for other drivers[0m
               Please refer to the QAPI documentation of the "blockdev-add" QMP command.

       [1m-drive [4m[22moption[24m[1m[,[4m[22moption[24m[1m[,[4m[22moption[24m[1m[,...]]][0m
           Define a new drive. This includes creating a block driver node (the backend) as well as a guest device, and is mostly a shortcut for defining the corresponding [1m-blockdev [22mand [1m-device [22moptions.

           [1m-drive [22maccepts all options that are accepted by [1m-blockdev[22m. In addition, it knows the following options:

           [1mfile=[4m[22mfile[0m
               This option defines which disk image to use with this drive. If the filename contains comma, you must double it (for instance, "file=my,,file" to use file "my,file").

               Special files such as iSCSI devices can be specified using protocol specific URLs. See the section for "Device URL Syntax" for more information.

           [1mif=[4m[22minterface[0m
               This option defines on which type on interface the drive is connected.  Available types are: ide, scsi, sd, mtd, floppy, pflash, virtio, none.

           [1mbus=[4m[22mbus[24m[1m,unit=[4m[22munit[0m
               These options define where is connected the drive by defining the bus number and the unit id.

           [1mindex=[4m[22mindex[0m
               This option defines where is connected the drive by using an index in the list of available connectors of a given interface type.

           [1mmedia=[4m[22mmedia[0m
               This option defines the type of the media: disk or cdrom.

           [1msnapshot=[4m[22msnapshot[0m
               [4msnapshot[24m is "on" or "off" and controls snapshot mode for the given drive (see [1m-snapshot[22m).

           [1mcache=[4m[22mcache[0m
               [4mcache[24m is "none", "writeback", "unsafe", "directsync" or "writethrough" and controls how the host cache is used to access block data. This is a shortcut that sets the [1mcache.direct [22mand [1mcache.no-flush [22moptions (as in
               [1m-blockdev[22m), and additionally [1mcache.writeback[22m, which provides a default for the [1mwrite-cache [22moption of block guest devices (as in [1m-device[22m). The modes correspond to the following settings:

                                    ‚îÇ cache.writeback   cache.direct   cache.no-flush
                       ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                       writeback    ‚îÇ on                off            off
                       none         ‚îÇ on                on             off
                       writethrough ‚îÇ off               off            off
                       directsync   ‚îÇ off               on             off
                       unsafe       ‚îÇ on                off            on

               The default mode is [1mcache=writeback[22m.

           [1maio=[4m[22maio[0m
               [4maio[24m is "threads", or "native" and selects between pthread based disk I/O and native Linux AIO.

           [1mformat=[4m[22mformat[0m
               Specify which disk [4mformat[24m will be used rather than detecting the format.  Can be used to specify format=raw to avoid interpreting an untrusted format header.

           [1mwerror=[4m[22maction[24m[1m,rerror=[4m[22maction[0m
               Specify which [4maction[24m to take on write and read errors. Valid actions are: "ignore" (ignore the error and try to continue), "stop" (pause QEMU), "report" (report the error to the guest), "enospc" (pause QEMU only if
               the host disk is full; report the error to the guest otherwise).  The default setting is [1mwerror=enospc [22mand [1mrerror=report[22m.

           [1mcopy-on-read=[4m[22mcopy-on-read[0m
               [4mcopy-on-read[24m is "on" or "off" and enables whether to copy read backing file sectors into the image file.

           [1mbps=[4m[22mb[24m[1m,bps_rd=[4m[22mr[24m[1m,bps_wr=[4m[22mw[0m
               Specify bandwidth throttling limits in bytes per second, either for all request types or for reads or writes only.  Small values can lead to timeouts or hangs inside the guest.  A safe minimum for disks is 2 MB/s.

           [1mbps_max=[4m[22mbm[24m[1m,bps_rd_max=[4m[22mrm[24m[1m,bps_wr_max=[4m[22mwm[0m
               Specify bursts in bytes per second, either for all request types or for reads or writes only.  Bursts allow the guest I/O to spike above the limit temporarily.

           [1miops=[4m[22mi[24m[1m,iops_rd=[4m[22mr[24m[1m,iops_wr=[4m[22mw[0m
               Specify request rate limits in requests per second, either for all request types or for reads or writes only.

           [1miops_max=[4m[22mbm[24m[1m,iops_rd_max=[4m[22mrm[24m[1m,iops_wr_max=[4m[22mwm[0m
               Specify bursts in requests per second, either for all request types or for reads or writes only.  Bursts allow the guest I/O to spike above the limit temporarily.

           [1miops_size=[4m[22mis[0m
               Let every [4mis[24m bytes of a request count as a new request for iops throttling purposes.  Use this option to prevent guests from circumventing iops limits by sending fewer but larger requests.

           [1mgroup=[4m[22mg[0m
               Join a throttling quota group with given name [4mg[24m.  All drives that are members of the same group are accounted for together.  Use this option to prevent guests from circumventing throttling limits by using many small
               disks instead of a single larger disk.

           By default, the [1mcache.writeback=on [22mmode is used. It will report data writes as completed as soon as the data is present in the host page cache.  This is safe as long as your guest OS makes sure to correctly flush disk
           caches where needed. If your guest OS does not handle volatile disk write caches correctly and your host crashes or loses power, then the guest may experience data corruption.

           For such guests, you should consider using [1mcache.writeback=off[22m. This means that the host page cache will be used to read and write data, but write notification will be sent to the guest only after QEMU has made sure to
           flush each write to the disk. Be aware that this has a major impact on performance.

           When using the [1m-snapshot [22moption, unsafe caching is always used.

           Copy-on-read avoids accessing the same backing file sectors repeatedly and is useful when the backing file is over a slow network.  By default copy-on-read is off.

           Instead of [1m-cdrom [22myou can use:

                   qemu-system-i386 -drive file=file,index=2,media=cdrom

           Instead of [1m-hda[22m, [1m-hdb[22m, [1m-hdc[22m, [1m-hdd[22m, you can use:

                   qemu-system-i386 -drive file=file,index=0,media=disk
                   qemu-system-i386 -drive file=file,index=1,media=disk
                   qemu-system-i386 -drive file=file,index=2,media=disk
                   qemu-system-i386 -drive file=file,index=3,media=disk

           You can open an image using pre-opened file descriptors from an fd set:

                   qemu-system-i386
                   -add-fd fd=3,set=2,opaque="rdwr:/path/to/file"
                   -add-fd fd=4,set=2,opaque="rdonly:/path/to/file"
                   -drive file=/dev/fdset/2,index=0,media=disk

           You can connect a CDROM to the slave of ide0:

                   qemu-system-i386 -drive file=file,if=ide,index=1,media=cdrom

           If you don't specify the "file=" argument, you define an empty drive:

                   qemu-system-i386 -drive if=ide,index=1,media=cdrom

           Instead of [1m-fda[22m, [1m-fdb[22m, you can use:

                   qemu-system-i386 -drive file=file,index=0,if=floppy
                   qemu-system-i386 -drive file=file,index=1,if=floppy

           By default, [4minterface[24m is "ide" and [4mindex[24m is automatically incremented:

                   qemu-system-i386 -drive file=a -drive file=b"

           is interpreted like:

                   qemu-system-i386 -hda a -hdb b

       [1m-mtdblock [4m[22mfile[0m
           Use [4mfile[24m as on-board Flash memory image.

       [1m-sd [4m[22mfile[0m
           Use [4mfile[24m as SecureDigital card image.

       [1m-pflash [4m[22mfile[0m
           Use [4mfile[24m as a parallel flash image.

       [1m-snapshot[0m
           Write to temporary files instead of disk image files. In this case, the raw disk image you use is not written back. You can however force the write back by pressing [1mC-a s[22m.

       [1m-fsdev [4m[22mfsdriver[24m[1m,id=[4m[22mid[24m[1m,path=[4m[22mpath[24m[1m,[security_model=[4m[22msecurity_model[24m[1m][,writeout=[4m[22mwriteout[24m[1m][,readonly][,socket=[4m[22msocket[24m[1m|sock_fd=[4m[22msock_fd[24m[1m][,fmode=[4m[22mfmode[24m[1m][,dmode=[4m[22mdmode[24m[1m][0m
           Define a new file system device. Valid options are:

           [4mfsdriver[0m
               This option specifies the fs driver backend to use.  Currently "local", "handle" and "proxy" file system drivers are supported.

           [1mid=[4m[22mid[0m
               Specifies identifier for this device

           [1mpath=[4m[22mpath[0m
               Specifies the export path for the file system device. Files under this path will be available to the 9p client on the guest.

           [1msecurity_model=[4m[22msecurity_model[0m
               Specifies the security model to be used for this export path.  Supported security models are "passthrough", "mapped-xattr", "mapped-file" and "none".  In "passthrough" security model, files are stored using the same
               credentials as they are created on the guest. This requires QEMU to run as root. In "mapped-xattr" security model, some of the file attributes like uid, gid, mode bits and link target are stored as file attributes.
               For "mapped-file" these attributes are stored in the hidden .virtfs_metadata directory. Directories exported by this security model cannot interact with other unix tools. "none" security model is same as passthrough
               except the sever won't report failures if it fails to set file attributes like ownership. Security model is mandatory only for local fsdriver. Other fsdrivers (like handle, proxy) don't take security model as a
               parameter.

           [1mwriteout=[4m[22mwriteout[0m
               This is an optional argument. The only supported value is "immediate".  This means that host page cache will be used to read and write data but write notification will be sent to the guest only when the data has been
               reported as written by the storage subsystem.

           [1mreadonly[0m
               Enables exporting 9p share as a readonly mount for guests. By default read-write access is given.

           [1msocket=[4m[22msocket[0m
               Enables proxy filesystem driver to use passed socket file for communicating with virtfs-proxy-helper

           [1msock_fd=[4m[22msock_fd[0m
               Enables proxy filesystem driver to use passed socket descriptor for communicating with virtfs-proxy-helper. Usually a helper like libvirt will create socketpair and pass one of the fds as sock_fd

           [1mfmode=[4m[22mfmode[0m
               Specifies the default mode for newly created files on the host. Works only with security models "mapped-xattr" and "mapped-file".

           [1mdmode=[4m[22mdmode[0m
               Specifies the default mode for newly created directories on the host. Works only with security models "mapped-xattr" and "mapped-file".

           -fsdev option is used along with -device driver "virtio-9p-pci".

       [1m-device virtio-9p-pci,fsdev=[4m[22mid[24m[1m,mount_tag=[4m[22mmount_tag[0m
           Options for virtio-9p-pci driver are:

           [1mfsdev=[4m[22mid[0m
               Specifies the id value specified along with -fsdev option

           [1mmount_tag=[4m[22mmount_tag[0m
               Specifies the tag name to be used by the guest to mount this export point

       [1m-virtfs [4m[22mfsdriver[24m[1m[,path=[4m[22mpath[24m[1m],mount_tag=[4m[22mmount_tag[24m[1m[,security_model=[4m[22msecurity_model[24m[1m][,writeout=[4m[22mwriteout[24m[1m][,readonly][,socket=[4m[22msocket[24m[1m|sock_fd=[4m[22msock_fd[24m[1m][,fmode=[4m[22mfmode[24m[1m][,dmode=[4m[22mdmode[24m[1m][0m
           The general form of a Virtual File system pass-through options are:

           [4mfsdriver[0m
               This option specifies the fs driver backend to use.  Currently "local", "handle" and "proxy" file system drivers are supported.

           [1mid=[4m[22mid[0m
               Specifies identifier for this device

           [1mpath=[4m[22mpath[0m
               Specifies the export path for the file system device. Files under this path will be available to the 9p client on the guest.

           [1msecurity_model=[4m[22msecurity_model[0m
               Specifies the security model to be used for this export path.  Supported security models are "passthrough", "mapped-xattr", "mapped-file" and "none".  In "passthrough" security model, files are stored using the same
               credentials as they are created on the guest. This requires QEMU to run as root. In "mapped-xattr" security model, some of the file attributes like uid, gid, mode bits and link target are stored as file attributes.
               For "mapped-file" these attributes are stored in the hidden .virtfs_metadata directory. Directories exported by this security model cannot interact with other unix tools. "none" security model is same as passthrough
               except the sever won't report failures if it fails to set file attributes like ownership. Security model is mandatory only for local fsdriver. Other fsdrivers (like handle, proxy) don't take security model as a
               parameter.

           [1mwriteout=[4m[22mwriteout[0m
               This is an optional argument. The only supported value is "immediate".  This means that host page cache will be used to read and write data but write notification will be sent to the guest only when the data has been
               reported as written by the storage subsystem.

           [1mreadonly[0m
               Enables exporting 9p share as a readonly mount for guests. By default read-write access is given.

           [1msocket=[4m[22msocket[0m
               Enables proxy filesystem driver to use passed socket file for communicating with virtfs-proxy-helper. Usually a helper like libvirt will create socketpair and pass one of the fds as sock_fd

           [1msock_fd[0m
               Enables proxy filesystem driver to use passed 'sock_fd' as the socket descriptor for interfacing with virtfs-proxy-helper

           [1mfmode=[4m[22mfmode[0m
               Specifies the default mode for newly created files on the host. Works only with security models "mapped-xattr" and "mapped-file".

           [1mdmode=[4m[22mdmode[0m
               Specifies the default mode for newly created directories on the host. Works only with security models "mapped-xattr" and "mapped-file".

       [1m-virtfs_synth[0m
           Create synthetic file system image

       [1m-iscsi[0m
           Configure iSCSI session parameters.

       [4mUSB[24m [4moptions[0m

       [1m-usb[0m
           Enable the USB driver (if it is not used by default yet).

       [1m-usbdevice [4m[22mdevname[0m
           Add the USB device [4mdevname[24m. Note that this option is deprecated, please use "-device usb-..." instead.

           [1mmouse[0m
               Virtual Mouse. This will override the PS/2 mouse emulation when activated.

           [1mtablet[0m
               Pointer device that uses absolute coordinates (like a touchscreen). This means QEMU is able to report the mouse position without having to grab the mouse. Also overrides the PS/2 mouse emulation when activated.

           [1mbraille[0m
               Braille device.  This will use BrlAPI to display the braille output on a real or fake device.

       [4mDisplay[24m [4moptions[0m

       [1m-display [4m[22mtype[0m
           Select type of display to use. This option is a replacement for the old style -sdl/-curses/... options. Valid values for [4mtype[24m are

           [1msdl [22mDisplay video output via SDL (usually in a separate graphics window; see the SDL documentation for other possibilities).

           [1mcurses[0m
               Display video output via curses. For graphics device models which support a text mode, QEMU can display this output using a curses/ncurses interface. Nothing is displayed when the graphics device is in graphical mode
               or if the graphics device does not support a text mode. Generally only the VGA device models support text mode.

           [1mnone[0m
               Do not display video output. The guest will still see an emulated graphics card, but its output will not be displayed to the QEMU user. This option differs from the -nographic option in that it only affects what is
               done with video output; -nographic also changes the destination of the serial and parallel port data.

           [1mgtk [22mDisplay video output in a GTK window. This interface provides drop-down menus and other UI elements to configure and control the VM during runtime.

           [1mvnc [22mStart a VNC server on display <arg>

           [1megl-headless[0m
               Offload all OpenGL operations to a local DRI device. For any graphical display, this display needs to be paired with either VNC or SPICE displays.

       [1m-nographic[0m
           Normally, if QEMU is compiled with graphical window support, it displays output such as guest graphics, guest console, and the QEMU monitor in a window. With this option, you can totally disable graphical output so that
           QEMU is a simple command line application. The emulated serial port is redirected on the console and muxed with the monitor (unless redirected elsewhere explicitly). Therefore, you can still use QEMU to debug a Linux
           kernel with a serial console. Use [1mC-a h [22mfor help on switching between the console and monitor.

       [1m-curses[0m
           Normally, if QEMU is compiled with graphical window support, it displays output such as guest graphics, guest console, and the QEMU monitor in a window. With this option, QEMU can display the VGA output when in text mode
           using a curses/ncurses interface. Nothing is displayed in graphical mode.

       [1m-no-frame[0m
           Do not use decorations for SDL windows and start them using the whole available screen space. This makes the using QEMU in a dedicated desktop workspace more convenient.

       [1m-alt-grab[0m
           Use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt). Note that this also affects the special keys (for fullscreen, monitor-mode switching, etc).

       [1m-ctrl-grab[0m
           Use Right-Ctrl to grab mouse (instead of Ctrl-Alt). Note that this also affects the special keys (for fullscreen, monitor-mode switching, etc).

       [1m-no-quit[0m
           Disable SDL window close capability.

       [1m-sdl[0m
           Enable SDL.

       [1m-spice [4m[22moption[24m[1m[,[4m[22moption[24m[1m[,...]][0m
           Enable the spice remote desktop protocol. Valid options are

           [1mport=<nr>[0m
               Set the TCP port spice is listening on for plaintext channels.

           [1maddr=<addr>[0m
               Set the IP address spice is listening on.  Default is any address.

           [1mipv4[0m
           [1mipv6[0m
           [1munix[0m
               Force using the specified IP version.

           [1mpassword=<secret>[0m
               Set the password you need to authenticate.

           [1msasl[0m
               Require that the client use SASL to authenticate with the spice.  The exact choice of authentication method used is controlled from the system / user's SASL configuration file for the 'qemu' service. This is
               typically found in /etc/sasl2/qemu.conf. If running QEMU as an unprivileged user, an environment variable SASL_CONF_PATH can be used to make it search alternate locations for the service config.  While some SASL auth
               methods can also provide data encryption (eg GSSAPI), it is recommended that SASL always be combined with the 'tls' and 'x509' settings to enable use of SSL and server certificates. This ensures a data encryption
               preventing compromise of authentication credentials.

           [1mdisable-ticketing[0m
               Allow client connects without authentication.

           [1mdisable-copy-paste[0m
               Disable copy paste between the client and the guest.

           [1mdisable-agent-file-xfer[0m
               Disable spice-vdagent based file-xfer between the client and the guest.

           [1mtls-port=<nr>[0m
               Set the TCP port spice is listening on for encrypted channels.

           [1mx509-dir=<dir>[0m
               Set the x509 file directory. Expects same filenames as -vnc $display,x509=$dir

           [1mx509-key-file=<file>[0m
           [1mx509-key-password=<file>[0m
           [1mx509-cert-file=<file>[0m
           [1mx509-cacert-file=<file>[0m
           [1mx509-dh-key-file=<file>[0m
               The x509 file names can also be configured individually.

           [1mtls-ciphers=<list>[0m
               Specify which ciphers to use.

           [1mtls-channel=[main|display|cursor|inputs|record|playback][0m
           [1mplaintext-channel=[main|display|cursor|inputs|record|playback][0m
               Force specific channel to be used with or without TLS encryption.  The options can be specified multiple times to configure multiple channels.  The special name "default" can be used to set the default mode.  For
               channels which are not explicitly forced into one mode the spice client is allowed to pick tls/plaintext as he pleases.

           [1mimage-compression=[auto_glz|auto_lz|quic|glz|lz|off][0m
               Configure image compression (lossless).  Default is auto_glz.

           [1mjpeg-wan-compression=[auto|never|always][0m
           [1mzlib-glz-wan-compression=[auto|never|always][0m
               Configure wan image compression (lossy for slow links).  Default is auto.

           [1mstreaming-video=[off|all|filter][0m
               Configure video stream detection.  Default is off.

           [1magent-mouse=[on|off][0m
               Enable/disable passing mouse events via vdagent.  Default is on.

           [1mplayback-compression=[on|off][0m
               Enable/disable audio stream compression (using celt 0.5.1).  Default is on.

           [1mseamless-migration=[on|off][0m
               Enable/disable spice seamless migration. Default is off.

           [1mgl=[on|off][0m
               Enable/disable OpenGL context. Default is off.

           [1mrendernode=<file>[0m
               DRM render node for OpenGL rendering. If not specified, it will pick the first available. (Since 2.9)

       [1m-portrait[0m
           Rotate graphical output 90 deg left (only PXA LCD).

       [1m-rotate [4m[22mdeg[0m
           Rotate graphical output some deg left (only PXA LCD).

       [1m-vga [4m[22mtype[0m
           Select type of VGA card to emulate. Valid values for [4mtype[24m are

           [1mcirrus[0m
               Cirrus Logic GD5446 Video card. All Windows versions starting from Windows 95 should recognize and use this graphic card. For optimal performances, use 16 bit color depth in the guest and the host OS.  (This card was
               the default before QEMU 2.2)

           [1mstd [22mStandard VGA card with Bochs VBE extensions.  If your guest OS supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if you want to use high resolution modes (>= 1280x1024x16) then you should use this option.
               (This card is the default since QEMU 2.2)

           [1mvmware[0m
               VMWare SVGA-II compatible adapter. Use it if you have sufficiently recent XFree86/XOrg server or Windows guest with a driver for this card.

           [1mqxl [22mQXL paravirtual graphic card.  It is VGA compatible (including VESA 2.0 VBE support).  Works best with qxl guest drivers installed though.  Recommended choice when using the spice protocol.

           [1mtcx [22m(sun4m only) Sun TCX framebuffer. This is the default framebuffer for sun4m machines and offers both 8-bit and 24-bit colour depths at a fixed resolution of 1024x768.

           [1mcg3 [22m(sun4m only) Sun cgthree framebuffer. This is a simple 8-bit framebuffer for sun4m machines available in both 1024x768 (OpenBIOS) and 1152x900 (OBP) resolutions aimed at people wishing to run older Solaris versions.

           [1mvirtio[0m
               Virtio VGA card.

           [1mnone[0m
               Disable VGA card.

       [1m-full-screen[0m
           Start in full screen.

       [1m-g [4m[22mwidth[24m[1mx[4m[22mheight[24m[1m[x[4m[22mdepth[24m[1m][0m
           Set the initial graphical resolution and depth (PPC, SPARC only).

       [1m-vnc [4m[22mdisplay[24m[1m[,[4m[22moption[24m[1m[,[4m[22moption[24m[1m[,...]]][0m
           Normally, if QEMU is compiled with graphical window support, it displays output such as guest graphics, guest console, and the QEMU monitor in a window. With this option, you can have QEMU listen on VNC display [4mdisplay[0m
           and redirect the VGA display over the VNC session. It is very useful to enable the usb tablet device when using this option (option [1m-device usb-tablet[22m). When using the VNC display, you must use the [1m-k [22mparameter to set
           the keyboard layout if you are not using en-us. Valid syntax for the [4mdisplay[24m is

           [1mto=[4m[22mL[0m
               With this option, QEMU will try next available VNC [4mdisplay[24ms, until the number [4mL[24m, if the origianlly defined "-vnc [4mdisplay[24m" is not available, e.g. port 5900+[4mdisplay[24m is already used by another application. By default,
               to=0.

           [4mhost[24m[1m:[4m[22md[0m
               TCP connections will only be allowed from [4mhost[24m on display [4md[24m.  By convention the TCP port is 5900+[4md[24m. Optionally, [4mhost[24m can be omitted in which case the server will accept connections from any host.

           [1munix:[4m[22mpath[0m
               Connections will be allowed over UNIX domain sockets where [4mpath[24m is the location of a unix socket to listen for connections on.

           [1mnone[0m
               VNC is initialized but not started. The monitor "change" command can be used to later start the VNC server.

           Following the [4mdisplay[24m value there may be one or more [4moption[24m flags separated by commas. Valid options are

           [1mreverse[0m
               Connect to a listening VNC client via a "reverse" connection. The client is specified by the [4mdisplay[24m. For reverse network connections ([4mhost[24m:[4md[24m,"reverse"), the [4md[24m argument is a TCP port number, not a display number.

           [1mwebsocket[0m
               Opens an additional TCP listening port dedicated to VNC Websocket connections.  If a bare [4mwebsocket[24m option is given, the Websocket port is 5700+[4mdisplay[24m. An alternative port can be specified with the syntax
               "websocket"=[4mport[24m.

               If [4mhost[24m is specified connections will only be allowed from this host.  It is possible to control the websocket listen address independently, using the syntax "websocket"=[4mhost[24m:[4mport[24m.

               If no TLS credentials are provided, the websocket connection runs in unencrypted mode. If TLS credentials are provided, the websocket connection requires encrypted client connections.

           [1mpassword[0m
               Require that password based authentication is used for client connections.

               The password must be set separately using the "set_password" command in the [1mpcsys_monitor[22m. The syntax to change your password is: "set_password <protocol> <password>" where <protocol> could be either "vnc" or
               "spice".

               If you would like to change <protocol> password expiration, you should use "expire_password <protocol> <expiration-time>" where expiration time could be one of the following options: now, never, +seconds or UNIX time
               of expiration, e.g. +60 to make password expire in 60 seconds, or 1335196800 to make password expire on "Mon Apr 23 12:00:00 EDT 2012" (UNIX time for this date and time).

               You can also use keywords "now" or "never" for the expiration time to allow <protocol> password to expire immediately or never expire.

           [1mtls-creds=[4m[22mID[0m
               Provides the ID of a set of TLS credentials to use to secure the VNC server. They will apply to both the normal VNC server socket and the websocket socket (if enabled). Setting TLS credentials will cause the VNC
               server socket to enable the VeNCrypt auth mechanism.  The credentials should have been previously created using the [1m-object tls-creds [22margument.

           [1msasl[0m
               Require that the client use SASL to authenticate with the VNC server.  The exact choice of authentication method used is controlled from the system / user's SASL configuration file for the 'qemu' service. This is
               typically found in /etc/sasl2/qemu.conf. If running QEMU as an unprivileged user, an environment variable SASL_CONF_PATH can be used to make it search alternate locations for the service config.  While some SASL auth
               methods can also provide data encryption (eg GSSAPI), it is recommended that SASL always be combined with the 'tls' and 'x509' settings to enable use of SSL and server certificates. This ensures a data encryption
               preventing compromise of authentication credentials. See the [1mvnc_security [22msection for details on using SASL authentication.

           [1macl [22mTurn on access control lists for checking of the x509 client certificate and SASL party. For x509 certs, the ACL check is made against the certificate's distinguished name. This is something that looks like
               "C=GB,O=ACME,L=Boston,CN=bob". For SASL party, the ACL check is made against the username, which depending on the SASL plugin, may include a realm component, eg "bob" or "bob@EXAMPLE.COM".  When the [1macl [22mflag is set,
               the initial access list will be empty, with a "deny" policy. Thus no one will be allowed to use the VNC server until the ACLs have been loaded. This can be achieved using the "acl" monitor command.

           [1mlossy[0m
               Enable lossy compression methods (gradient, JPEG, ...). If this option is set, VNC client may receive lossy framebuffer updates depending on its encoding settings. Enabling this option can save a lot of bandwidth at
               the expense of quality.

           [1mnon-adaptive[0m
               Disable adaptive encodings. Adaptive encodings are enabled by default.  An adaptive encoding will try to detect frequently updated screen regions, and send updates in these regions using a lossy encoding (like JPEG).
               This can be really helpful to save bandwidth when playing videos. Disabling adaptive encodings restores the original static behavior of encodings like Tight.

           [1mshare=[allow-exclusive|force-shared|ignore][0m
               Set display sharing policy.  'allow-exclusive' allows clients to ask for exclusive access.  As suggested by the rfb spec this is implemented by dropping other connections.  Connecting multiple clients in parallel
               requires all clients asking for a shared session (vncviewer: -shared switch).  This is the default.  'force-shared' disables exclusive client access.  Useful for shared desktop sessions, where you don't want someone
               forgetting specify -shared disconnect everybody else.  'ignore' completely ignores the shared flag and allows everybody connect unconditionally.  Doesn't conform to the rfb spec but is traditional QEMU behavior.

           [1mkey-delay-ms[0m
               Set keyboard delay, for key down and key up events, in milliseconds.  Default is 10.  Keyboards are low-bandwidth devices, so this slowdown can help the device and guest to keep up and not lose events in case events
               are arriving in bulk.  Possible causes for the latter are flaky network connections, or scripts for automated testing.

       [4mi386[24m [4mtarget[24m [4monly[0m

       [1m-win2k-hack[0m
           Use it when installing Windows 2000 to avoid a disk full bug. After Windows 2000 is installed, you no longer need this option (this option slows down the IDE transfers).

       [1m-no-fd-bootchk[0m
           Disable boot signature checking for floppy disks in BIOS. May be needed to boot from old floppy disks.

       [1m-no-acpi[0m
           Disable ACPI (Advanced Configuration and Power Interface) support. Use it if your guest OS complains about ACPI problems (PC target machine only).

       [1m-no-hpet[0m
           Disable HPET support.

       [1m-acpitable [sig=[4m[22mstr[24m[1m][,rev=[4m[22mn[24m[1m][,oem_id=[4m[22mstr[24m[1m][,oem_table_id=[4m[22mstr[24m[1m][,oem_rev=[4m[22mn[24m[1m] [,asl_compiler_id=[4m[22mstr[24m[1m][,asl_compiler_rev=[4m[22mn[24m[1m][,data=[4m[22mfile1[24m[1m[:[4m[22mfile2[24m[1m]...][0m
           Add ACPI table with specified header fields and context from specified files.  For file=, take whole ACPI table from the specified files, including all ACPI headers (possible overridden by other options).  For data=,
           only data portion of the table is used, all header information is specified in the command line.  If a SLIC table is supplied to QEMU, then the SLIC's oem_id and oem_table_id fields will override the same in the RSDT and
           the FADT (a.k.a. FACP), in order to ensure the field matches required by the Microsoft SLIC spec and the ACPI spec.

       [1m-smbios file=[4m[22mbinary[0m
           Load SMBIOS entry from binary file.

       [1m-smbios type=0[,vendor=[4m[22mstr[24m[1m][,version=[4m[22mstr[24m[1m][,date=[4m[22mstr[24m[1m][,release=[4m[22m%d.%d[24m[1m][,uefi=on|off][0m
           Specify SMBIOS type 0 fields

       [1m-smbios type=1[,manufacturer=[4m[22mstr[24m[1m][,product=[4m[22mstr[24m[1m][,version=[4m[22mstr[24m[1m][,serial=[4m[22mstr[24m[1m][,uuid=[4m[22muuid[24m[1m][,sku=[4m[22mstr[24m[1m][,family=[4m[22mstr[24m[1m][0m
           Specify SMBIOS type 1 fields

       [1m-smbios type=2[,manufacturer=[4m[22mstr[24m[1m][,product=[4m[22mstr[24m[1m][,version=[4m[22mstr[24m[1m][,serial=[4m[22mstr[24m[1m][,asset=[4m[22mstr[24m[1m][,location=[4m[22mstr[24m[1m][,family=[4m[22mstr[24m[1m][0m
           Specify SMBIOS type 2 fields

       [1m-smbios type=3[,manufacturer=[4m[22mstr[24m[1m][,version=[4m[22mstr[24m[1m][,serial=[4m[22mstr[24m[1m][,asset=[4m[22mstr[24m[1m][,sku=[4m[22mstr[24m[1m][0m
           Specify SMBIOS type 3 fields

       [1m-smbios type=4[,sock_pfx=[4m[22mstr[24m[1m][,manufacturer=[4m[22mstr[24m[1m][,version=[4m[22mstr[24m[1m][,serial=[4m[22mstr[24m[1m][,asset=[4m[22mstr[24m[1m][,part=[4m[22mstr[24m[1m][0m
           Specify SMBIOS type 4 fields

       [1m-smbios type=17[,loc_pfx=[4m[22mstr[24m[1m][,bank=[4m[22mstr[24m[1m][,manufacturer=[4m[22mstr[24m[1m][,serial=[4m[22mstr[24m[1m][,asset=[4m[22mstr[24m[1m][,part=[4m[22mstr[24m[1m][,speed=[4m[22m%d[24m[1m][0m
           Specify SMBIOS type 17 fields

       [4mNetwork[24m [4moptions[0m

       [1m-nic [tap|bridge|user|l2tpv3|vde|netmap|vhost-user|socket][,...][,mac=macaddr][,model=mn][0m
           This option is a shortcut for configuring both the on-board (default) guest NIC hardware and the host network backend in one go. The host backend options are the same as with the corresponding [1m-netdev [22moptions below.  The
           guest NIC model can be set with [1mmodel=[4m[22mmodelname[24m.  Use [1mmodel=help [22mto list the available device types.  The hardware MAC address can be set with [1mmac=[4m[22mmacaddr[24m.

           The following two example do exactly the same, to show how [1m-nic [22mcan be used to shorten the command line length (note that the e1000 is the default on i386, so the [1mmodel=e1000 [22mparameter could even be omitted here, too):

                   qemu-system-i386 -netdev user,id=n1,ipv6=off -device e1000,netdev=n1,mac=52:54:98:76:54:32
                   qemu-system-i386 -nic user,ipv6=off,model=e1000,mac=52:54:98:76:54:32

       [1m-nic none[0m
           Indicate that no network devices should be configured. It is used to override the default configuration (default NIC with "user" host network backend) which is activated if no other networking options are provided.

       [1m-netdev user,id=[4m[22mid[24m[1m[,[4m[22moption[24m[1m][,[4m[22moption[24m[1m][,...][0m
           Configure user mode host network backend which requires no administrator privilege to run. Valid options are:

           [1mid=[4m[22mid[0m
               Assign symbolic name for use in monitor commands.

           [1mipv4=on|off and ipv6=on|off[0m
               Specify that either IPv4 or IPv6 must be enabled. If neither is specified both protocols are enabled.

           [1mnet=[4m[22maddr[24m[1m[/[4m[22mmask[24m[1m][0m
               Set IP network address the guest will see. Optionally specify the netmask, either in the form a.b.c.d or as number of valid top-most bits. Default is 10.0.2.0/24.

           [1mhost=[4m[22maddr[0m
               Specify the guest-visible address of the host. Default is the 2nd IP in the guest network, i.e. x.x.x.2.

           [1mipv6-net=[4m[22maddr[24m[1m[/[4m[22mint[24m[1m][0m
               Set IPv6 network address the guest will see (default is fec0::/64). The network prefix is given in the usual hexadecimal IPv6 address notation. The prefix size is optional, and is given as the number of valid top-
               most bits (default is 64).

           [1mipv6-host=[4m[22maddr[0m
               Specify the guest-visible IPv6 address of the host. Default is the 2nd IPv6 in the guest network, i.e. xxxx::2.

           [1mrestrict=on|off[0m
               If this option is enabled, the guest will be isolated, i.e. it will not be able to contact the host and no guest IP packets will be routed over the host to the outside. This option does not affect any explicitly set
               forwarding rules.

           [1mhostname=[4m[22mname[0m
               Specifies the client hostname reported by the built-in DHCP server.

           [1mdhcpstart=[4m[22maddr[0m
               Specify the first of the 16 IPs the built-in DHCP server can assign. Default is the 15th to 31st IP in the guest network, i.e. x.x.x.15 to x.x.x.31.

           [1mdns=[4m[22maddr[0m
               Specify the guest-visible address of the virtual nameserver. The address must be different from the host address. Default is the 3rd IP in the guest network, i.e. x.x.x.3.

           [1mipv6-dns=[4m[22maddr[0m
               Specify the guest-visible address of the IPv6 virtual nameserver. The address must be different from the host address. Default is the 3rd IP in the guest network, i.e. xxxx::3.

           [1mdnssearch=[4m[22mdomain[0m
               Provides an entry for the domain-search list sent by the built-in DHCP server. More than one domain suffix can be transmitted by specifying this option multiple times. If supported, this will cause the guest to
               automatically try to append the given domain suffix(es) in case a domain name can not be resolved.

               Example:

                       qemu-system-i386 -nic user,dnssearch=mgmt.example.org,dnssearch=example.org

           [1mdomainname=[4m[22mdomain[0m
               Specifies the client domain name reported by the built-in DHCP server.

           [1mtftp=[4m[22mdir[0m
               When using the user mode network stack, activate a built-in TFTP server. The files in [4mdir[24m will be exposed as the root of a TFTP server.  The TFTP client on the guest must be configured in binary mode (use the command
               "bin" of the Unix TFTP client).

           [1mtftp-server-name=[4m[22mname[0m
               In BOOTP reply, broadcast [4mname[24m as the "TFTP server name" (RFC2132 option 66). This can be used to advise the guest to load boot files or configurations from a different server than the host address.

           [1mbootfile=[4m[22mfile[0m
               When using the user mode network stack, broadcast [4mfile[24m as the BOOTP filename. In conjunction with [1mtftp[22m, this can be used to network boot a guest from a local directory.

               Example (using pxelinux):

                       qemu-system-i386 -hda linux.img -boot n -device e1000,netdev=n1 \
                       -netdev user,id=n1,tftp=/path/to/tftp/files,bootfile=/pxelinux.0

           [1msmb=[4m[22mdir[24m[1m[,smbserver=[4m[22maddr[24m[1m][0m
               When using the user mode network stack, activate a built-in SMB server so that Windows OSes can access to the host files in [4mdir[24m transparently. The IP address of the SMB server can be set to [4maddr[24m. By default the 4th
               IP in the guest network is used, i.e. x.x.x.4.

               In the guest Windows OS, the line:

                       10.0.2.4 smbserver

               must be added in the file [4mC:\WINDOWS\LMHOSTS[24m (for windows 9x/Me) or [4mC:\WINNT\SYSTEM32\DRIVERS\ETC\LMHOSTS[24m (Windows NT/2000).

               Then [4mdir[24m can be accessed in [4m\\smbserver\qemu[24m.

               Note that a SAMBA server must be installed on the host OS.

           [1mhostfwd=[tcp|udp]:[[4m[22mhostaddr[24m[1m]:[4m[22mhostport[24m[1m-[[4m[22mguestaddr[24m[1m]:[4m[22mguestport[0m
               Redirect incoming TCP or UDP connections to the host port [4mhostport[24m to the guest IP address [4mguestaddr[24m on guest port [4mguestport[24m. If [4mguestaddr[24m is not specified, its value is x.x.x.15 (default first address given by the
               built-in DHCP server). By specifying [4mhostaddr[24m, the rule can be bound to a specific host interface. If no connection type is set, TCP is used. This option can be given multiple times.

               For example, to redirect host X11 connection from screen 1 to guest screen 0, use the following:

                       # on the host
                       qemu-system-i386 -nic user,hostfwd=tcp:127.0.0.1:6001-:6000
                       # this host xterm should open in the guest X11 server
                       xterm -display :1

               To redirect telnet connections from host port 5555 to telnet port on the guest, use the following:

                       # on the host
                       qemu-system-i386 -nic user,hostfwd=tcp::5555-:23
                       telnet localhost 5555

               Then when you use on the host "telnet localhost 5555", you connect to the guest telnet server.

           [1mguestfwd=[tcp]:[4m[22mserver[24m[1m:[4m[22mport[24m[1m-[4m[22mdev[0m
           [1mguestfwd=[tcp]:[4m[22mserver[24m[1m:[4m[22mport[24m[1m-[4m[22mcmd:command[0m
               Forward guest TCP connections to the IP address [4mserver[24m on port [4mport[24m to the character device [4mdev[24m or to a program executed by [4mcmd:command[24m which gets spawned for each connection. This option can be given multiple times.

               You can either use a chardev directly and have that one used throughout QEMU's lifetime, like in the following example:

                       # open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever
                       # the guest accesses it
                       qemu-system-i386 -nic user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321

               Or you can execute a command on every TCP connection established by the guest, so that QEMU behaves similar to an inetd process for that virtual server:

                       # call "netcat 10.10.1.1 4321" on every TCP connection to 10.0.2.100:1234
                       # and connect the TCP stream to its stdin/stdout
                       qemu-system-i386 -nic  'user,id=n1,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'

       [1m-netdev tap,id=[4m[22mid[24m[1m[,fd=[4m[22mh[24m[1m][,ifname=[4m[22mname[24m[1m][,script=[4m[22mfile[24m[1m][,downscript=[4m[22mdfile[24m[1m][,br=[4m[22mbridge[24m[1m][,helper=[4m[22mhelper[24m[1m][0m
           Configure a host TAP network backend with ID [4mid[24m.

           Use the network script [4mfile[24m to configure it and the network script [4mdfile[24m to deconfigure it. If [4mname[24m is not provided, the OS automatically provides one. The default network configure script is [4m/etc/qemu-ifup[24m and the
           default network deconfigure script is [4m/etc/qemu-ifdown[24m. Use [1mscript=no [22mor [1mdownscript=no [22mto disable script execution.

           If running QEMU as an unprivileged user, use the network helper [4mhelper[24m to configure the TAP interface and attach it to the bridge.  The default network helper executable is [4m/path/to/qemu-bridge-helper[24m and the default
           bridge device is [4mbr0[24m.

           [1mfd[22m=[4mh[24m can be used to specify the handle of an already opened host TAP interface.

           Examples:

                   #launch a QEMU instance with the default network script
                   qemu-system-i386 linux.img -nic tap

                   #launch a QEMU instance with two NICs, each one connected
                   #to a TAP device
                   qemu-system-i386 linux.img \
                   -netdev tap,id=nd0,ifname=tap0 -device e1000,netdev=nd0 \
                   -netdev tap,id=nd1,ifname=tap1 -device rtl8139,netdev=nd1

                   #launch a QEMU instance with the default network helper to
                   #connect a TAP device to bridge br0
                   qemu-system-i386 linux.img -device virtio-net-pci,netdev=n1 \
                   -netdev tap,id=n1,"helper=/path/to/qemu-bridge-helper"

       [1m-netdev bridge,id=[4m[22mid[24m[1m[,br=[4m[22mbridge[24m[1m][,helper=[4m[22mhelper[24m[1m][0m
           Connect a host TAP network interface to a host bridge device.

           Use the network helper [4mhelper[24m to configure the TAP interface and attach it to the bridge. The default network helper executable is [4m/path/to/qemu-bridge-helper[24m and the default bridge device is [4mbr0[24m.

           Examples:

                   #launch a QEMU instance with the default network helper to
                   #connect a TAP device to bridge br0
                   qemu-system-i386 linux.img -netdev bridge,id=n1 -device virtio-net,netdev=n1

                   #launch a QEMU instance with the default network helper to
                   #connect a TAP device to bridge qemubr0
                   qemu-system-i386 linux.img -netdev bridge,br=qemubr0,id=n1 -device virtio-net,netdev=n1

       [1m-netdev socket,id=[4m[22mid[24m[1m[,fd=[4m[22mh[24m[1m][,listen=[[4m[22mhost[24m[1m]:[4m[22mport[24m[1m][,connect=[4m[22mhost[24m[1m:[4m[22mport[24m[1m][0m
           This host network backend can be used to connect the guest's network to another QEMU virtual machine using a TCP socket connection. If [1mlisten [22mis specified, QEMU waits for incoming connections on [4mport[24m ([4mhost[24m is optional).
           [1mconnect [22mis used to connect to another QEMU instance using the [1mlisten [22moption. [1mfd[22m=[4mh[24m specifies an already opened TCP socket.

           Example:

                   # launch a first QEMU instance
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                   -netdev socket,id=n1,listen=:1234
                   # connect the network of this instance to the network of the first instance
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
                   -netdev socket,id=n2,connect=127.0.0.1:1234

       [1m-netdev socket,id=[4m[22mid[24m[1m[,fd=[4m[22mh[24m[1m][,mcast=[4m[22mmaddr[24m[1m:[4m[22mport[24m[1m[,localaddr=[4m[22maddr[24m[1m]][0m
           Configure a socket host network backend to share the guest's network traffic with another QEMU virtual machines using a UDP multicast socket, effectively making a bus for every QEMU with same multicast address [4mmaddr[24m and
           [4mport[24m.  NOTES:

           1.  Several QEMU can be running on different hosts and share same bus (assuming correct multicast setup for these hosts).

           2.  mcast support is compatible with User Mode Linux (argument [1meth[4m[22mN[24m[1m=mcast[22m), see <[1mhttp://user-mode-linux.sf.net[22m>.

           3.  Use [1mfd=h [22mto specify an already opened UDP multicast socket.

           Example:

                   # launch one QEMU instance
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                   -netdev socket,id=n1,mcast=230.0.0.1:1234
                   # launch another QEMU instance on same "bus"
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n2,mac=52:54:00:12:34:57 \
                   -netdev socket,id=n2,mcast=230.0.0.1:1234
                   # launch yet another QEMU instance on same "bus"
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n3,mac=52:54:00:12:34:58 \
                   -netdev socket,id=n3,mcast=230.0.0.1:1234

           Example (User Mode Linux compat.):

                   # launch QEMU instance (note mcast address selected is UML's default)
                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                   -netdev socket,id=n1,mcast=239.192.168.1:1102
                   # launch UML
                   /path/to/linux ubd0=/path/to/root_fs eth0=mcast

           Example (send packets from host's 1.2.3.4):

                   qemu-system-i386 linux.img \
                   -device e1000,netdev=n1,mac=52:54:00:12:34:56 \
                   -netdev socket,id=n1,mcast=239.192.168.1:1102,localaddr=1.2.3.4

       [1m-netdev[0m
       [1ml2tpv3,id=[4m[22mid[24m[1m,src=[4m[22msrcaddr[24m[1m,dst=[4m[22mdstaddr[24m[1m[,srcport=[4m[22msrcport[24m[1m][,dstport=[4m[22mdstport[24m[1m],txsession=[4m[22mtxsession[24m[1m[,rxsession=[4m[22mrxsession[24m[1m][,ipv6][,udp][,cookie64][,counter][,pincounter][,txcookie=[4m[22mtxcookie[24m[1m][,rxcookie=[4m[22mrxcookie[24m[1m][,offset=[4m[22moffset[24m[1m][0m
           Configure a L2TPv3 pseudowire host network backend. L2TPv3 (RFC3391) is a popular protocol to transport Ethernet (and other Layer 2) data frames between two systems. It is present in routers, firewalls and the Linux
           kernel (from version 3.3 onwards).

           This transport allows a VM to communicate to another VM, router or firewall directly.

           [1msrc=[4m[22msrcaddr[0m
               source address (mandatory)

           [1mdst=[4m[22mdstaddr[0m
               destination address (mandatory)

           [1mudp [22mselect udp encapsulation (default is ip).

           [1msrcport=[4m[22msrcport[0m
               source udp port.

           [1mdstport=[4m[22mdstport[0m
               destination udp port.

           [1mipv6[0m
               force v6, otherwise defaults to v4.

           [1mrxcookie=[4m[22mrxcookie[0m
           [1mtxcookie=[4m[22mtxcookie[0m
               Cookies are a weak form of security in the l2tpv3 specification.  Their function is mostly to prevent misconfiguration. By default they are 32 bit.

           [1mcookie64[0m
               Set cookie size to 64 bit instead of the default 32

           [1mcounter=off[0m
               Force a 'cut-down' L2TPv3 with no counter as in draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00

           [1mpincounter=on[0m
               Work around broken counter handling in peer. This may also help on networks which have packet reorder.

           [1moffset=[4m[22moffset[0m
               Add an extra offset between header and data

           For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to the bridge br-lan on the remote Linux host 1.2.3.4:

                   # Setup tunnel on linux host using raw ip as encapsulation
                   # on 1.2.3.4
                   ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \
                   encap udp udp_sport 16384 udp_dport 16384
                   ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \
                   0xFFFFFFFF peer_session_id 0xFFFFFFFF
                   ifconfig vmtunnel0 mtu 1500
                   ifconfig vmtunnel0 up
                   brctl addif br-lan vmtunnel0

                   # on 4.3.2.1
                   # launch QEMU instance - if your network has reorder or is very lossy add ,pincounter

                   qemu-system-i386 linux.img -device e1000,netdev=n1 \
                   -netdev l2tpv3,id=n1,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter

       [1m-netdev vde,id=[4m[22mid[24m[1m[,sock=[4m[22msocketpath[24m[1m][,port=[4m[22mn[24m[1m][,group=[4m[22mgroupname[24m[1m][,mode=[4m[22moctalmode[24m[1m][0m
           Configure VDE backend to connect to PORT [4mn[24m of a vde switch running on host and listening for incoming connections on [4msocketpath[24m. Use GROUP [4mgroupname[24m and MODE [4moctalmode[24m to change default ownership and permissions for
           communication port. This option is only available if QEMU has been compiled with vde support enabled.

           Example:

                   # launch vde switch
                   vde_switch -F -sock /tmp/myswitch
                   # launch QEMU instance
                   qemu-system-i386 linux.img -nic vde,sock=/tmp/myswitch

       [1m-netdev vhost-user,chardev=[4m[22mid[24m[1m[,vhostforce=on|off][,queues=n][0m
           Establish a vhost-user netdev, backed by a chardev [4mid[24m. The chardev should be a unix domain socket backed one. The vhost-user uses a specifically defined protocol to pass vhost ioctl replacement messages to an application
           on the other end of the socket. On non-MSIX guests, the feature can be forced with [4mvhostforce[24m. Use 'queues=[4mn[24m' to specify the number of queues to be created for multiqueue vhost-user.

           Example:

                   qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \
                   -numa node,memdev=mem \
                   -chardev socket,id=chr0,path=/path/to/socket \
                   -netdev type=vhost-user,id=net0,chardev=chr0 \
                   -device virtio-net-pci,netdev=net0

       [1m-netdev hubport,id=[4m[22mid[24m[1m,hubid=[4m[22mhubid[24m[1m[,netdev=[4m[22mnd[24m[1m][0m
           Create a hub port on the emulated hub with ID [4mhubid[24m.

           The hubport netdev lets you connect a NIC to a QEMU emulated hub instead of a single netdev. Alternatively, you can also connect the hubport to another netdev with ID [4mnd[24m by using the [1mnetdev=[4m[22mnd[24m option.

       [1m-net nic[,netdev=[4m[22mnd[24m[1m][,macaddr=[4m[22mmac[24m[1m][,model=[4m[22mtype[24m[1m] [,name=[4m[22mname[24m[1m][,addr=[4m[22maddr[24m[1m][,vectors=[4m[22mv[24m[1m][0m
           Legacy option to configure or create an on-board (or machine default) Network Interface Card(NIC) and connect it either to the emulated hub with ID 0 (i.e.  the default hub), or to the netdev [4mnd[24m.  The NIC is an e1000 by
           default on the PC target. Optionally, the MAC address can be changed to [4mmac[24m, the device address set to [4maddr[24m (PCI cards only), and a [4mname[24m can be assigned for use in monitor commands.  Optionally, for PCI cards, you can
           specify the number [4mv[24m of MSI-X vectors that the card should have; this option currently only affects virtio cards; set [4mv[24m = 0 to disable MSI-X. If no [1m-net [22moption is specified, a single NIC is created.  QEMU can emulate
           several different models of network card.  Use "-net nic,model=help" for a list of available devices for your target.

       [1m-net user|tap|bridge|socket|l2tpv3|vde[,...][,name=[4m[22mname[24m[1m][0m
           Configure a host network backend (with the options corresponding to the same [1m-netdev [22moption) and connect it to the emulated hub 0 (the default hub). Use [4mname[24m to specify the name of the hub port.

       [4mCharacter[24m [4mdevice[24m [4moptions[0m

       The general form of a character device option is:

       [1m-chardev [4m[22mbackend[24m[1m,id=[4m[22mid[24m[1m[,mux=on|off][,[4m[22moptions[24m[1m][0m
           Backend is one of: [1mnull[22m, [1msocket[22m, [1mudp[22m, [1mmsmouse[22m, [1mvc[22m, [1mringbuf[22m, [1mfile[22m, [1mpipe[22m, [1mconsole[22m, [1mserial[22m, [1mpty[22m, [1mstdio[22m, [1mbraille[22m, [1mtty[22m, [1mparallel[22m, [1mparport[22m, [1mspicevmc[22m, [1mspiceport[22m.  The specific backend will determine the applicable options.

           Use "-chardev help" to print all available chardev backend types.

           All devices must have an id, which can be any string up to 127 characters long.  It is used to uniquely identify this device in other command line directives.

           A character device may be used in multiplexing mode by multiple front-ends.  Specify [1mmux=on [22mto enable this mode.  A multiplexer is a "1:N" device, and here the "1" end is your specified chardev backend, and the "N" end
           is the various parts of QEMU that can talk to a chardev.  If you create a chardev with [1mid=myid [22mand [1mmux=on[22m, QEMU will create a multiplexer with your specified ID, and you can then configure multiple front ends to use that
           chardev ID for their input/output. Up to four different front ends can be connected to a single multiplexed chardev. (Without multiplexing enabled, a chardev can only be used by a single front end.)  For instance you
           could use this to allow a single stdio chardev to be used by two serial ports and the QEMU monitor:

                   -chardev stdio,mux=on,id=char0 \
                   -mon chardev=char0,mode=readline \
                   -serial chardev:char0 \
                   -serial chardev:char0

           You can have more than one multiplexer in a system configuration; for instance you could have a TCP port multiplexed between UART 0 and UART 1, and stdio multiplexed between the QEMU monitor and a parallel port:

                   -chardev stdio,mux=on,id=char0 \
                   -mon chardev=char0,mode=readline \
                   -parallel chardev:char0 \
                   -chardev tcp,...,mux=on,id=char1 \
                   -serial chardev:char1 \
                   -serial chardev:char1

           When you're using a multiplexed character device, some escape sequences are interpreted in the input.

           Note that some other command line options may implicitly create multiplexed character backends; for instance [1m-serial mon:stdio [22mcreates a multiplexed stdio backend connected to the serial port and the QEMU monitor, and
           [1m-nographic [22malso multiplexes the console and the monitor to stdio.

           There is currently no support for multiplexing in the other direction (where a single QEMU front end takes input and output from multiple chardevs).

           Every backend supports the [1mlogfile [22moption, which supplies the path to a file to record all data transmitted via the backend. The [1mlogappend [22moption controls whether the log file will be truncated or appended to when
           opened.

       The available backends are:

       [1m-chardev null,id=[4m[22mid[0m
           A void device. This device will not emit any data, and will drop any data it receives. The null backend does not take any options.

       [1m-chardev socket,id=[4m[22mid[24m[1m[,[4m[22mTCP[24m [4moptions[24m [1mor [4m[22munix[24m [4moptions[24m[1m][,server][,nowait][,telnet][,websocket][,reconnect=[4m[22mseconds[24m[1m][,tls-creds=[4m[22mid[24m[1m][0m
           Create a two-way stream socket, which can be either a TCP or a unix socket. A unix socket will be created if [1mpath [22mis specified. Behaviour is undefined if TCP options are specified for a unix socket.

           [1mserver [22mspecifies that the socket shall be a listening socket.

           [1mnowait [22mspecifies that QEMU should not block waiting for a client to connect to a listening socket.

           [1mtelnet [22mspecifies that traffic on the socket should interpret telnet escape sequences.

           [1mwebsocket [22mspecifies that the socket uses WebSocket protocol for communication.

           [1mreconnect [22msets the timeout for reconnecting on non-server sockets when the remote end goes away.  qemu will delay this many seconds and then attempt to reconnect.  Zero disables reconnecting, and is the default.

           [1mtls-creds [22mrequests enablement of the TLS protocol for encryption, and specifies the id of the TLS credentials to use for the handshake. The credentials must be previously created with the [1m-object tls-creds [22margument.

           TCP and unix socket options are given below:

           [1mTCP options: port=[4m[22mport[24m[1m[,host=[4m[22mhost[24m[1m][,to=[4m[22mto[24m[1m][,ipv4][,ipv6][,nodelay][0m
               [1mhost [22mfor a listening socket specifies the local address to be bound.  For a connecting socket species the remote host to connect to. [1mhost [22mis optional for listening sockets. If not specified it defaults to 0.0.0.0.

               [1mport [22mfor a listening socket specifies the local port to be bound. For a connecting socket specifies the port on the remote host to connect to.  [1mport [22mcan be given as either a port number or a service name.  [1mport [22mis
               required.

               [1mto [22mis only relevant to listening sockets. If it is specified, and [1mport [22mcannot be bound, QEMU will attempt to bind to subsequent ports up to and including [1mto [22muntil it succeeds. [1mto [22mmust be specified as a port number.

               [1mipv4 [22mand [1mipv6 [22mspecify that either IPv4 or IPv6 must be used.  If neither is specified the socket may use either protocol.

               [1mnodelay [22mdisables the Nagle algorithm.

           [1munix options: path=[4m[22mpath[0m
               [1mpath [22mspecifies the local path of the unix socket. [1mpath [22mis required.

       [1m-chardev udp,id=[4m[22mid[24m[1m[,host=[4m[22mhost[24m[1m],port=[4m[22mport[24m[1m[,localaddr=[4m[22mlocaladdr[24m[1m][,localport=[4m[22mlocalport[24m[1m][,ipv4][,ipv6][0m
           Sends all traffic from the guest to a remote host over UDP.

           [1mhost [22mspecifies the remote host to connect to. If not specified it defaults to "localhost".

           [1mport [22mspecifies the port on the remote host to connect to. [1mport [22mis required.

           [1mlocaladdr [22mspecifies the local address to bind to. If not specified it defaults to 0.0.0.0.

           [1mlocalport [22mspecifies the local port to bind to. If not specified any available local port will be used.

           [1mipv4 [22mand [1mipv6 [22mspecify that either IPv4 or IPv6 must be used.  If neither is specified the device may use either protocol.

       [1m-chardev msmouse,id=[4m[22mid[0m
           Forward QEMU's emulated msmouse events to the guest. [1mmsmouse [22mdoes not take any options.

       [1m-chardev vc,id=[4m[22mid[24m[1m[[,width=[4m[22mwidth[24m[1m][,height=[4m[22mheight[24m[1m]][[,cols=[4m[22mcols[24m[1m][,rows=[4m[22mrows[24m[1m]][0m
           Connect to a QEMU text console. [1mvc [22mmay optionally be given a specific size.

           [1mwidth [22mand [1mheight [22mspecify the width and height respectively of the console, in pixels.

           [1mcols [22mand [1mrows [22mspecify that the console be sized to fit a text console with the given dimensions.

       [1m-chardev ringbuf,id=[4m[22mid[24m[1m[,size=[4m[22msize[24m[1m][0m
           Create a ring buffer with fixed size [1msize[22m.  [4msize[24m must be a power of two and defaults to "64K".

       [1m-chardev file,id=[4m[22mid[24m[1m,path=[4m[22mpath[0m
           Log all traffic received from the guest to a file.

           [1mpath [22mspecifies the path of the file to be opened. This file will be created if it does not already exist, and overwritten if it does. [1mpath [22mis required.

       [1m-chardev pipe,id=[4m[22mid[24m[1m,path=[4m[22mpath[0m
           Create a two-way connection to the guest. The behaviour differs slightly between Windows hosts and other hosts:

           On Windows, a single duplex pipe will be created at [4m\\.pipe\[1mpath[24m[22m.

           On other hosts, 2 pipes will be created called [4m[1mpath[22m.in[24m and [4m[1mpath[22m.out[24m. Data written to [4m[1mpath[22m.in[24m will be received by the guest. Data written by the guest can be read from [4m[1mpath[22m.out[24m. QEMU will not create these fifos, and
           requires them to be present.

           [1mpath [22mforms part of the pipe path as described above. [1mpath [22mis required.

       [1m-chardev console,id=[4m[22mid[0m
           Send traffic from the guest to QEMU's standard output. [1mconsole [22mdoes not take any options.

           [1mconsole [22mis only available on Windows hosts.

       [1m-chardev serial,id=[4m[22mid[24m[1m,path=path[0m
           Send traffic from the guest to a serial device on the host.

           On Unix hosts serial will actually accept any tty device, not only serial lines.

           [1mpath [22mspecifies the name of the serial device to open.

       [1m-chardev pty,id=[4m[22mid[0m
           Create a new pseudo-terminal on the host and connect to it. [1mpty [22mdoes not take any options.

           [1mpty [22mis not available on Windows hosts.

       [1m-chardev stdio,id=[4m[22mid[24m[1m[,signal=on|off][0m
           Connect to standard input and standard output of the QEMU process.

           [1msignal [22mcontrols if signals are enabled on the terminal, that includes exiting QEMU with the key sequence [1mControl-c[22m. This option is enabled by default, use [1msignal=off [22mto disable it.

       [1m-chardev braille,id=[4m[22mid[0m
           Connect to a local BrlAPI server. [1mbraille [22mdoes not take any options.

       [1m-chardev tty,id=[4m[22mid[24m[1m,path=[4m[22mpath[0m
           [1mtty [22mis only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD and DragonFlyBSD hosts.  It is an alias for [1mserial[22m.

           [1mpath [22mspecifies the path to the tty. [1mpath [22mis required.

       [1m-chardev parallel,id=[4m[22mid[24m[1m,path=[4m[22mpath[0m
       [1m-chardev parport,id=[4m[22mid[24m[1m,path=[4m[22mpath[0m
           [1mparallel [22mis only available on Linux, FreeBSD and DragonFlyBSD hosts.

           Connect to a local parallel port.

           [1mpath [22mspecifies the path to the parallel port device. [1mpath [22mis required.

       [1m-chardev spicevmc,id=[4m[22mid[24m[1m,debug=[4m[22mdebug[24m[1m,name=[4m[22mname[0m
           [1mspicevmc [22mis only available when spice support is built in.

           [1mdebug [22mdebug level for spicevmc

           [1mname [22mname of spice channel to connect to

           Connect to a spice virtual machine channel, such as vdiport.

       [1m-chardev spiceport,id=[4m[22mid[24m[1m,debug=[4m[22mdebug[24m[1m,name=[4m[22mname[0m
           [1mspiceport [22mis only available when spice support is built in.

           [1mdebug [22mdebug level for spicevmc

           [1mname [22mname of spice port to connect to

           Connect to a spice port, allowing a Spice client to handle the traffic identified by a name (preferably a fqdn).

       [4mBluetooth(R)[24m [4moptions[0m

       [1m-bt hci[...][0m
           Defines the function of the corresponding Bluetooth HCI.  -bt options are matched with the HCIs present in the chosen machine type.  For example when emulating a machine with only one HCI built into it, only the first
           "-bt hci[...]" option is valid and defines the HCI's logic.  The Transport Layer is decided by the machine type.  Currently the machines "n800" and "n810" have one HCI and all other machines have none.

           Note: This option and the whole bluetooth subsystem is considered as deprecated.  If you still use it, please send a mail to <[1mqemu-devel@nongnu.org[22m> where you describe your usecase.

           The following three types are recognized:

           [1m-bt hci,null[0m
               (default) The corresponding Bluetooth HCI assumes no internal logic and will not respond to any HCI commands or emit events.

           [1m-bt hci,host[:[4m[22mid[24m[1m][0m
               ("bluez" only) The corresponding HCI passes commands / events to / from the physical HCI identified by the name [4mid[24m (default: "hci0") on the computer running QEMU.  Only available on "bluez" capable systems like
               Linux.

           [1m-bt hci[,vlan=[4m[22mn[24m[1m][0m
               Add a virtual, standard HCI that will participate in the Bluetooth scatternet [4mn[24m (default 0).  Similarly to [1m-net [22mVLANs, devices inside a bluetooth network [4mn[24m can only communicate with other devices in the same network
               (scatternet).

       [1m-bt vhci[,vlan=[4m[22mn[24m[1m][0m
           (Linux-host only) Create a HCI in scatternet [4mn[24m (default 0) attached to the host bluetooth stack instead of to the emulated target.  This allows the host and target machines to participate in a common scatternet and
           communicate.  Requires the Linux "vhci" driver installed.  Can be used as following:

                   qemu-system-i386 [...OPTIONS...] -bt hci,vlan=5 -bt vhci,vlan=5

       [1m-bt device:[4m[22mdev[24m[1m[,vlan=[4m[22mn[24m[1m][0m
           Emulate a bluetooth device [4mdev[24m and place it in network [4mn[24m (default 0).  QEMU can only emulate one type of bluetooth devices currently:

           [1mkeyboard[0m
               Virtual wireless keyboard implementing the HIDP bluetooth profile.

       [4mTPM[24m [4mdevice[24m [4moptions[0m

       The general form of a TPM device option is:

       [1m-tpmdev [4m[22mbackend[24m[1m,id=[4m[22mid[24m[1m[,[4m[22moptions[24m[1m][0m
           The specific backend type will determine the applicable options.  The "-tpmdev" option creates the TPM backend and requires a "-device" option that specifies the TPM frontend interface model.

           Use "-tpmdev help" to print all available TPM backend types.

       The available backends are:

       [1m-tpmdev passthrough,id=[4m[22mid[24m[1m,path=[4m[22mpath[24m[1m,cancel-path=[4m[22mcancel-path[0m
           (Linux-host only) Enable access to the host's TPM using the passthrough driver.

           [1mpath [22mspecifies the path to the host's TPM device, i.e., on a Linux host this would be "/dev/tpm0".  [1mpath [22mis optional and by default "/dev/tpm0" is used.

           [1mcancel-path [22mspecifies the path to the host TPM device's sysfs entry allowing for cancellation of an ongoing TPM command.  [1mcancel-path [22mis optional and by default QEMU will search for the sysfs entry to use.

           Some notes about using the host's TPM with the passthrough driver:

           The TPM device accessed by the passthrough driver must not be used by any other application on the host.

           Since the host's firmware (BIOS/UEFI) has already initialized the TPM, the VM's firmware (BIOS/UEFI) will not be able to initialize the TPM again and may therefore not show a TPM-specific menu that would otherwise allow
           the user to configure the TPM, e.g., allow the user to enable/disable or activate/deactivate the TPM.  Further, if TPM ownership is released from within a VM then the host's TPM will get disabled and deactivated. To
           enable and activate the TPM again afterwards, the host has to be rebooted and the user is required to enter the firmware's menu to enable and activate the TPM.  If the TPM is left disabled and/or deactivated most TPM
           commands will fail.

           To create a passthrough TPM use the following two options:

                   -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0

           Note that the "-tpmdev" id is "tpm0" and is referenced by "tpmdev=tpm0" in the device option.

       [1m-tpmdev emulator,id=[4m[22mid[24m[1m,chardev=[4m[22mdev[0m
           (Linux-host only) Enable access to a TPM emulator using Unix domain socket based chardev backend.

           [1mchardev [22mspecifies the unique ID of a character device backend that provides connection to the software TPM server.

           To create a TPM emulator backend device with chardev socket backend:

                   -chardev socket,id=chrtpm,path=/tmp/swtpm-sock -tpmdev emulator,id=tpm0,chardev=chrtpm -device tpm-tis,tpmdev=tpm0

       [4mLinux/Multiboot[24m [4mboot[24m [4mspecific[0m

       When using these options, you can use a given Linux or Multiboot kernel without installing it in the disk image. It can be useful for easier testing of various kernels.

       [1m-kernel [4m[22mbzImage[0m
           Use [4mbzImage[24m as kernel image. The kernel can be either a Linux kernel or in multiboot format.

       [1m-append [4m[22mcmdline[0m
           Use [4mcmdline[24m as kernel command line

       [1m-initrd [4m[22mfile[0m
           Use [4mfile[24m as initial ram disk.

       [1m-initrd "[4m[22mfile1[24m [1marg=foo,[4m[22mfile2[24m[1m"[0m
           This syntax is only available with multiboot.

           Use [4mfile1[24m and [4mfile2[24m as modules and pass arg=foo as parameter to the first module.

       [1m-dtb [4m[22mfile[0m
           Use [4mfile[24m as a device tree binary (dtb) image and pass it to the kernel on boot.

       [4mDebug/Expert[24m [4moptions[0m

       [1m-fw_cfg [name=][4m[22mname[24m[1m,file=[4m[22mfile[0m
           Add named fw_cfg entry with contents from file [4mfile[24m.

       [1m-fw_cfg [name=][4m[22mname[24m[1m,string=[4m[22mstr[0m
           Add named fw_cfg entry with contents from string [4mstr[24m.

           The terminating NUL character of the contents of [4mstr[24m will not be included as part of the fw_cfg item data. To insert contents with embedded NUL characters, you have to use the [4mfile[24m parameter.

           The fw_cfg entries are passed by QEMU through to the guest.

           Example:

                   -fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin

           creates an fw_cfg entry named opt/com.mycompany/blob with contents from ./my_blob.bin.

       [1m-serial [4m[22mdev[0m
           Redirect the virtual serial port to host character device [4mdev[24m. The default device is "vc" in graphical mode and "stdio" in non graphical mode.

           This option can be used several times to simulate up to 4 serial ports.

           Use "-serial none" to disable all serial ports.

           Available character devices are:

           [1mvc[:[4m[22mW[24m[1mx[4m[22mH[24m[1m][0m
               Virtual console. Optionally, a width and height can be given in pixel with

                       vc:800x600

               It is also possible to specify width or height in characters:

                       vc:80Cx24C

           [1mpty [22m[Linux only] Pseudo TTY (a new PTY is automatically allocated)

           [1mnone[0m
               No device is allocated.

           [1mnull[0m
               void device

           [1mchardev:[4m[22mid[0m
               Use a named character device defined with the "-chardev" option.

           [1m/dev/XXX[0m
               [Linux only] Use host tty, e.g. [4m/dev/ttyS0[24m. The host serial port parameters are set according to the emulated ones.

           [1m/dev/parport[4m[22mN[0m
               [Linux only, parallel port only] Use host parallel port [4mN[24m. Currently SPP and EPP parallel port features can be used.

           [1mfile:[4m[22mfilename[0m
               Write output to [4mfilename[24m. No character can be read.

           [1mstdio[0m
               [Unix only] standard input/output

           [1mpipe:[4m[22mfilename[0m
               name pipe [4mfilename[0m

           [1mCOM[4m[22mn[0m
               [Windows only] Use host serial port [4mn[0m

           [1mudp:[[4m[22mremote_host[24m[1m]:[4m[22mremote_port[24m[1m[@[[4m[22msrc_ip[24m[1m]:[4m[22msrc_port[24m[1m][0m
               This implements UDP Net Console.  When [4mremote_host[24m or [4msrc_ip[24m are not specified they default to 0.0.0.0.  When not using a specified [4msrc_port[24m a random port is automatically chosen.

               If you just want a simple readonly console you can use "netcat" or "nc", by starting QEMU with: "-serial udp::4555" and nc as: "nc -u -l -p 4555". Any time QEMU writes something to that port it will appear in the
               netconsole session.

               If you plan to send characters back via netconsole or you want to stop and start QEMU a lot of times, you should have QEMU use the same source port each time by using something like "-serial udp::4555@4556" to QEMU.
               Another approach is to use a patched version of netcat which can listen to a TCP port and send and receive characters via udp.  If you have a patched version of netcat which activates telnet remote echo and single
               char transfer, then you can use the following options to set up a netcat redirector to allow telnet on port 5555 to access the QEMU port.

               "QEMU Options:"
                   -serial udp::4555@4556

               "netcat options:"
                   -u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T

               "telnet options:"
                   localhost 5555

           [1mtcp:[[4m[22mhost[24m[1m]:[4m[22mport[24m[1m[,[4m[22mserver[24m[1m][,nowait][,nodelay][,reconnect=[4m[22mseconds[24m[1m][0m
               The TCP Net Console has two modes of operation.  It can send the serial I/O to a location or wait for a connection from a location.  By default the TCP Net Console is sent to [4mhost[24m at the [4mport[24m.  If you use the [4mserver[0m
               option QEMU will wait for a client socket application to connect to the port before continuing, unless the "nowait" option was specified.  The "nodelay" option disables the Nagle buffering algorithm.  The "reconnect"
               option only applies if [4mnoserver[24m is set, if the connection goes down it will attempt to reconnect at the given interval.  If [4mhost[24m is omitted, 0.0.0.0 is assumed. Only one TCP connection at a time is accepted. You can
               use "telnet" to connect to the corresponding character device.

               "Example to send tcp console to 192.168.0.2 port 4444"
                   -serial tcp:192.168.0.2:4444

               "Example to listen and wait on port 4444 for connection"
                   -serial tcp::4444,server

               "Example to not wait and listen on ip 192.168.0.100 port 4444"
                   -serial tcp:192.168.0.100:4444,server,nowait

           [1mtelnet:[4m[22mhost[24m[1m:[4m[22mport[24m[1m[,server][,nowait][,nodelay][0m
               The telnet protocol is used instead of raw tcp sockets.  The options work the same as if you had specified "-serial tcp".  The difference is that the port acts like a telnet server or client using telnet option
               negotiation.  This will also allow you to send the MAGIC_SYSRQ sequence if you use a telnet that supports sending the break sequence.  Typically in unix telnet you do it with Control-] and then type "send break"
               followed by pressing the enter key.

           [1mwebsocket:[4m[22mhost[24m[1m:[4m[22mport[24m[1m,server[,nowait][,nodelay][0m
               The WebSocket protocol is used instead of raw tcp socket. The port acts as a WebSocket server. Client mode is not supported.

           [1munix:[4m[22mpath[24m[1m[,server][,nowait][,reconnect=[4m[22mseconds[24m[1m][0m
               A unix domain socket is used instead of a tcp socket.  The option works the same as if you had specified "-serial tcp" except the unix domain socket [4mpath[24m is used for connections.

           [1mmon:[4m[22mdev_string[0m
               This is a special option to allow the monitor to be multiplexed onto another serial port.  The monitor is accessed with key sequence of [1mControl-a [22mand then pressing [1mc[22m.  [4mdev_string[24m should be any one of the serial
               devices specified above.  An example to multiplex the monitor onto a telnet server listening on port 4444 would be:

               "-serial mon:telnet::4444,server,nowait"

               When the monitor is multiplexed to stdio in this way, Ctrl+C will not terminate QEMU any more but will be passed to the guest instead.

           [1mbraille[0m
               Braille device.  This will use BrlAPI to display the braille output on a real or fake device.

           [1mmsmouse[0m
               Three button serial mouse. Configure the guest to use Microsoft protocol.

       [1m-parallel [4m[22mdev[0m
           Redirect the virtual parallel port to host device [4mdev[24m (same devices as the serial port). On Linux hosts, [4m/dev/parportN[24m can be used to use hardware devices connected on the corresponding host parallel port.

           This option can be used several times to simulate up to 3 parallel ports.

           Use "-parallel none" to disable all parallel ports.

       [1m-monitor [4m[22mdev[0m
           Redirect the monitor to host device [4mdev[24m (same devices as the serial port).  The default device is "vc" in graphical mode and "stdio" in non graphical mode.  Use "-monitor none" to disable the default monitor.

       [1m-qmp [4m[22mdev[0m
           Like -monitor but opens in 'control' mode.

       [1m-qmp-pretty [4m[22mdev[0m
           Like -qmp but uses pretty JSON formatting.

       [1m-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]][0m
           Setup monitor on chardev [4mname[24m. "pretty" turns on JSON pretty printing easing human reading and debugging.

       [1m-debugcon [4m[22mdev[0m
           Redirect the debug console to host device [4mdev[24m (same devices as the serial port).  The debug console is an I/O port which is typically port 0xe9; writing to that I/O port sends output to this device.  The default device
           is "vc" in graphical mode and "stdio" in non graphical mode.

       [1m-pidfile [4m[22mfile[0m
           Store the QEMU process PID in [4mfile[24m. It is useful if you launch QEMU from a script.

       [1m-singlestep[0m
           Run the emulation in single step mode.

       [1m--preconfig[0m
           Pause QEMU for interactive configuration before the machine is created, which allows querying and configuring properties that will affect machine initialization.  Use QMP command 'x-exit-preconfig' to exit the preconfig
           state and move to the next state (i.e. run guest if -S isn't used or pause the second time if -S is used).  This option is experimental.

       [1m-S  [22mDo not start CPU at startup (you must type 'c' in the monitor).

       [1m-realtime mlock=on|off[0m
           Run qemu with realtime features.  mlocking qemu and guest memory can be enabled via [1mmlock=on [22m(enabled by default).

       [1m-overcommit mem-lock=on|off[0m
       [1m-overcommit cpu-pm=on|off[0m
           Run qemu with hints about host resource overcommit. The default is to assume that host overcommits all resources.

           Locking qemu and guest memory can be enabled via [1mmem-lock=on [22m(disabled by default).  This works when host memory is not overcommitted and reduces the worst-case latency for guest.  This is equivalent to [1mrealtime[22m.

           Guest ability to manage power state of host cpus (increasing latency for other processes on the same host cpu, but decreasing latency for guest) can be enabled via [1mcpu-pm=on [22m(disabled by default).  This works best when
           host CPU is not overcommitted. When used, host estimates of CPU cycle and power utilization will be incorrect, not taking into account guest idle time.

       [1m-gdb [4m[22mdev[0m
           Wait for gdb connection on device [4mdev[24m. Typical connections will likely be TCP-based, but also UDP, pseudo TTY, or even stdio are reasonable use case. The latter is allowing to start QEMU from within gdb and establish the
           connection via a pipe:

                   (gdb) target remote | exec qemu-system-i386 -gdb stdio ...

       [1m-s  [22mShorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234.

       [1m-d [4m[22mitem1[24m[1m[,...][0m
           Enable logging of specified items. Use '-d help' for a list of log items.

       [1m-D [4m[22mlogfile[0m
           Output log in [4mlogfile[24m instead of to stderr

       [1m-dfilter [4m[22mrange1[24m[1m[,...][0m
           Filter debug output to that relevant to a range of target addresses. The filter spec can be either [4mstart[24m+[4msize[24m, [4mstart[24m-[4msize[24m or [4mstart[24m..[4mend[24m where [4mstart[24m [4mend[24m and [4msize[24m are the addresses and sizes required. For example:

                   -dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000

           Will dump output for any code in the 0x1000 sized block starting at 0x8000 and the 0x200 sized block starting at 0xffffffc000080000 and another 0x1000 sized block starting at 0xffffffc00005f000.

       [1m-L  [4m[22mpath[0m
           Set the directory for the BIOS, VGA BIOS and keymaps.

           To list all the data directories, use "-L help".

       [1m-bios [4m[22mfile[0m
           Set the filename for the BIOS.

       [1m-enable-kvm[0m
           Enable KVM full virtualization support. This option is only available if KVM support is enabled when compiling.

       [1m-enable-hax[0m
           Enable HAX (Hardware-based Acceleration eXecution) support. This option is only available if HAX support is enabled when compiling. HAX is only applicable to MAC and Windows platform, and thus does not conflict with KVM.
           This option is deprecated, use [1m-accel hax [22minstead.

       [1m-xen-domid [4m[22mid[0m
           Specify xen guest domain [4mid[24m (XEN only).

       [1m-xen-create[0m
           Create domain using xen hypercalls, bypassing xend.  Warning: should not be used when xend is in use (XEN only).

       [1m-xen-attach[0m
           Attach to existing xen domain.  xend will use this when starting QEMU (XEN only).  Restrict set of available xen operations to specified domain id (XEN only).

       [1m-no-reboot[0m
           Exit instead of rebooting.

       [1m-no-shutdown[0m
           Don't exit QEMU on guest shutdown, but instead only stop the emulation.  This allows for instance switching to monitor to commit changes to the disk image.

       [1m-loadvm [4m[22mfile[0m
           Start right away with a saved state ("loadvm" in monitor)

       [1m-daemonize[0m
           Daemonize the QEMU process after initialization.  QEMU will not detach from standard IO until it is ready to receive connections on any of its devices.  This option is a useful way for external programs to launch QEMU
           without having to cope with initialization race conditions.

       [1m-option-rom [4m[22mfile[0m
           Load the contents of [4mfile[24m as an option ROM.  This option is useful to load things like EtherBoot.

       [1m-rtc [base=utc|localtime|[4m[22mdatetime[24m[1m][,clock=host|rt|vm][,driftfix=none|slew][0m
           Specify [1mbase [22mas "utc" or "localtime" to let the RTC start at the current UTC or local time, respectively. "localtime" is required for correct date in MS-DOS or Windows. To start at a specific point in time, provide
           [4mdatetime[24m in the format "2006-06-17T16:01:21" or "2006-06-17". The default base is UTC.

           By default the RTC is driven by the host system time. This allows using of the RTC as accurate reference clock inside the guest, specifically if the host time is smoothly following an accurate external reference clock,
           e.g. via NTP.  If you want to isolate the guest time from the host, you can set [1mclock [22mto "rt" instead, which provides a host monotonic clock if host support it.  To even prevent the RTC from progressing during
           suspension, you can set [1mclock [22mto "vm" (virtual clock). [1mclock=vm [22mis recommended especially in icount mode in order to preserve determinism; however, note that in icount mode the speed of the virtual clock is variable and
           can in general differ from the host clock.

           Enable [1mdriftfix [22m(i386 targets only) if you experience time drift problems, specifically with Windows' ACPI HAL. This option will try to figure out how many timer interrupts were not processed by the Windows guest and
           will re-inject them.

       [1m-icount [shift=[4m[22mN[24m[1m|auto][,rr=record|replay,rrfile=[4m[22mfilename[24m[1m,rrsnapshot=[4m[22msnapshot[24m[1m][0m
           Enable virtual instruction counter.  The virtual cpu will execute one instruction every 2^[4mN[24m ns of virtual time.  If "auto" is specified then the virtual cpu speed will be automatically adjusted to keep virtual time
           within a few seconds of real time.

           When the virtual cpu is sleeping, the virtual time will advance at default speed unless [1msleep=on|off [22mis specified.  With [1msleep=on|off[22m, the virtual time will jump to the next timer deadline instantly whenever the virtual
           cpu goes to sleep mode and will not advance if no timer is enabled. This behavior give deterministic execution times from the guest point of view.

           Note that while this option can give deterministic behavior, it does not provide cycle accurate emulation.  Modern CPUs contain superscalar out of order cores with complex cache hierarchies.  The number of instructions
           executed often has little or no correlation with actual performance.

           [1malign=on [22mwill activate the delay algorithm which will try to synchronise the host clock and the virtual clock. The goal is to have a guest running at the real frequency imposed by the shift option.  Whenever the guest
           clock is behind the host clock and if [1malign=on [22mis specified then we print a message to the user to inform about the delay.  Currently this option does not work when [1mshift [22mis "auto".  Note: The sync algorithm will work
           for those shift values for which the guest clock runs ahead of the host clock. Typically this happens when the shift value is high (how high depends on the host machine).

           When [1mrr [22moption is specified deterministic record/replay is enabled.  Replay log is written into [4mfilename[24m file in record mode and read from this file in replay mode.

           Option rrsnapshot is used to create new vm snapshot named [4msnapshot[24m at the start of execution recording. In replay mode this option is used to load the initial VM state.

       [1m-watchdog [4m[22mmodel[0m
           Create a virtual hardware watchdog device.  Once enabled (by a guest action), the watchdog must be periodically polled by an agent inside the guest or else the guest will be restarted. Choose a model for which your guest
           has drivers.

           The [4mmodel[24m is the model of hardware watchdog to emulate. Use "-watchdog help" to list available hardware models. Only one watchdog can be enabled for a guest.

           The following models may be available:

           [1mib700[0m
               iBASE 700 is a very simple ISA watchdog with a single timer.

           [1mi6300esb[0m
               Intel 6300ESB I/O controller hub is a much more featureful PCI-based dual-timer watchdog.

           [1mdiag288[0m
               A virtual watchdog for s390x backed by the diagnose 288 hypercall (currently KVM only).

       [1m-watchdog-action [4m[22maction[0m
           The [4maction[24m controls what QEMU will do when the watchdog timer expires.  The default is "reset" (forcefully reset the guest).  Other possible actions are: "shutdown" (attempt to gracefully shutdown the guest), "poweroff"
           (forcefully poweroff the guest), "inject-nmi" (inject a NMI into the guest), "pause" (pause the guest), "debug" (print a debug message and continue), or "none" (do nothing).

           Note that the "shutdown" action requires that the guest responds to ACPI signals, which it may not be able to do in the sort of situations where the watchdog would have expired, and thus "-watchdog-action shutdown" is
           not recommended for production use.

           Examples:

           "-watchdog i6300esb -watchdog-action pause"
           "-watchdog ib700"
       [1m-echr [4m[22mnumeric_ascii_value[0m
           Change the escape character used for switching to the monitor when using monitor and serial sharing.  The default is 0x01 when using the "-nographic" option.  0x01 is equal to pressing "Control-a".  You can select a
           different character from the ascii control keys where 1 through 26 map to Control-a through Control-z.  For instance you could use the either of the following to change the escape character to Control-t.

           "-echr 0x14"
           "-echr 20"
       [1m-virtioconsole [4m[22mc[0m
           Set virtio console.  This option is deprecated, please use [1m-device virtconsole [22minstead.

       [1m-show-cursor[0m
           Show cursor.

       [1m-tb-size [4m[22mn[0m
           Set TB size.

       [1m-incoming tcp:[[4m[22mhost[24m[1m]:[4m[22mport[24m[1m[,to=[4m[22mmaxport[24m[1m][,ipv4][,ipv6][0m
       [1m-incoming rdma:[4m[22mhost[24m[1m:[4m[22mport[24m[1m[,ipv4][,ipv6][0m
           Prepare for incoming migration, listen on a given tcp port.

       [1m-incoming unix:[4m[22msocketpath[0m
           Prepare for incoming migration, listen on a given unix socket.

       [1m-incoming fd:[4m[22mfd[0m
           Accept incoming migration from a given filedescriptor.

       [1m-incoming exec:[4m[22mcmdline[0m
           Accept incoming migration as an output from specified external command.

       [1m-incoming defer[0m
           Wait for the URI to be specified via migrate_incoming.  The monitor can be used to change settings (such as migration parameters) prior to issuing the migrate_incoming to allow the migration to begin.

       [1m-only-migratable[0m
           Only allow migratable devices. Devices will not be allowed to enter an unmigratable state.

       [1m-nodefaults[0m
           Don't create default devices. Normally, QEMU sets the default devices like serial port, parallel port, virtual console, monitor device, VGA adapter, floppy and CD-ROM drive and others. The "-nodefaults" option will
           disable all those default devices.

       [1m-chroot [4m[22mdir[0m
           Immediately before starting guest execution, chroot to the specified directory.  Especially useful in combination with -runas.

       [1m-runas [4m[22muser[0m
           Immediately before starting guest execution, drop root privileges, switching to the specified user.

       [1m-prom-env [4m[22mvariable[24m[1m=[4m[22mvalue[0m
           Set OpenBIOS nvram [4mvariable[24m to given [4mvalue[24m (PPC, SPARC only).

       [1m-semihosting[0m
           Enable semihosting mode (ARM, M68K, Xtensa, MIPS only).

       [1m-semihosting-config [enable=on|off][,target=native|gdb|auto][,arg=str[,...]][0m
           Enable and configure semihosting (ARM, M68K, Xtensa, MIPS only).

           [1mtarget="native|gdb|auto"[0m
               Defines where the semihosting calls will be addressed, to QEMU ("native") or to GDB ("gdb"). The default is "auto", which means "gdb" during debug sessions and "native" otherwise.

           [1marg=[4m[22mstr1[24m[1m,arg=[4m[22mstr2[24m[1m,...[0m
               Allows the user to pass input arguments, and can be used multiple times to build up a list. The old-style "-kernel"/"-append" method of passing a command line is still supported for backward compatibility. If both
               the "--semihosting-config arg" and the "-kernel"/"-append" are specified, the former is passed to semihosting as it always takes precedence.

       [1m-old-param[0m
           Old param mode (ARM only).

       [1m-sandbox [4m[22marg[24m[1m[,obsolete=[4m[22mstring[24m[1m][,elevateprivileges=[4m[22mstring[24m[1m][,spawn=[4m[22mstring[24m[1m][,resourcecontrol=[4m[22mstring[24m[1m][0m
           Enable Seccomp mode 2 system call filter. 'on' will enable syscall filtering and 'off' will disable it.  The default is 'off'.

           [1mobsolete=[4m[22mstring[0m
               Enable Obsolete system calls

           [1melevateprivileges=[4m[22mstring[0m
               Disable set*uid|gid system calls

           [1mspawn=[4m[22mstring[0m
               Disable *fork and execve

           [1mresourcecontrol=[4m[22mstring[0m
               Disable process affinity and schedular priority

       [1m-readconfig [4m[22mfile[0m
           Read device configuration from [4mfile[24m. This approach is useful when you want to spawn QEMU process with many command line options but you don't want to exceed the command line character limit.

       [1m-writeconfig [4m[22mfile[0m
           Write device configuration to [4mfile[24m. The [4mfile[24m can be either filename to save command line and device configuration into file or dash "-") character to print the output to stdout. This can be later used as input file for
           "-readconfig" option.

       [1m-no-user-config[0m
           The "-no-user-config" option makes QEMU not load any of the user-provided config files on [4msysconfdir[24m.

       [1m-trace [[enable=][4m[22mpattern[24m[1m][,events=[4m[22mfile[24m[1m][,file=[4m[22mfile[24m[1m][0m
           Specify tracing options.

           [1m[enable=][4m[22mpattern[0m
               Immediately enable events matching [4mpattern[24m (either event name or a globbing pattern).  This option is only available if QEMU has been compiled with the [4msimple[24m, [4mlog[24m or [4mftrace[24m tracing backend.  To specify multiple
               events or patterns, specify the [1m-trace [22moption multiple times.

               Use "-trace help" to print a list of names of trace points.

           [1mevents=[4m[22mfile[0m
               Immediately enable events listed in [4mfile[24m.  The file must contain one event name (as listed in the [4mtrace-events-all[24m file) per line; globbing patterns are accepted too.  This option is only available if QEMU has been
               compiled with the [4msimple[24m, [4mlog[24m or [4mftrace[24m tracing backend.

           [1mfile=[4m[22mfile[0m
               Log output traces to [4mfile[24m.  This option is only available if QEMU has been compiled with the [4msimple[24m tracing backend.

       [1m-enable-fips[0m
           Enable FIPS 140-2 compliance mode.

       [1m-msg timestamp[=on|off][0m
           prepend a timestamp to each log message.(default:on)

       [1m-dump-vmstate [4m[22mfile[0m
           Dump json-encoded vmstate information for current machine type to file in [4mfile[0m

       [1m-enable-sync-profile[0m
           Enable synchronization profiling.

       [4mGeneric[24m [4mobject[24m [4mcreation[0m

       [1m-object [4m[22mtypename[24m[1m[,[4m[22mprop1[24m[1m=[4m[22mvalue1[24m[1m,...][0m
           Create a new object of type [4mtypename[24m setting properties in the order they are specified.  Note that the 'id' property must be set.  These objects are placed in the '/objects' path.

           [1m-object memory-backend-file,id=[4m[22mid[24m[1m,size=[4m[22msize[24m[1m,mem-path=[4m[22mdir[24m[1m,share=[4m[22mon|off[24m[1m,discard-data=[4m[22mon|off[24m[1m,merge=[4m[22mon|off[24m[1m,dump=[4m[22mon|off[24m[1m,prealloc=[4m[22mon|off[24m[1m,host-nodes=[4m[22mhost-nodes[24m[1m,policy=[4m[22mdefault|preferred|bind|interleave[24m[1m,align=[4m[22malign[0m
               Creates a memory file backend object, which can be used to back the guest RAM with huge pages.

               The [1mid [22mparameter is a unique ID that will be used to reference this memory region when configuring the [1m-numa [22margument.

               The [1msize [22moption provides the size of the memory region, and accepts common suffixes, eg [1m500M[22m.

               The [1mmem-path [22mprovides the path to either a shared memory or huge page filesystem mount.

               The [1mshare [22mboolean option determines whether the memory region is marked as private to QEMU, or shared. The latter allows a co-operating external process to access the QEMU memory region.

               The [1mshare [22mis also required for pvrdma devices due to limitations in the RDMA API provided by Linux.

               Setting share=on might affect the ability to configure NUMA bindings for the memory backend under some circumstances, see Documentation/vm/numa_memory_policy.txt on the Linux kernel source tree for additional
               details.

               Setting the [1mdiscard-data [22mboolean option to [4mon[24m indicates that file contents can be destroyed when QEMU exits, to avoid unnecessarily flushing data to the backing file.  Note that [1mdiscard-data [22mis only an optimization,
               and QEMU might not discard file contents if it aborts unexpectedly or is terminated using SIGKILL.

               The [1mmerge [22mboolean option enables memory merge, also known as MADV_MERGEABLE, so that Kernel Samepage Merging will consider the pages for memory deduplication.

               Setting the [1mdump [22mboolean option to [4moff[24m excludes the memory from core dumps. This feature is also known as MADV_DONTDUMP.

               The [1mprealloc [22mboolean option enables memory preallocation.

               The [1mhost-nodes [22moption binds the memory range to a list of NUMA host nodes.

               The [1mpolicy [22moption sets the NUMA policy to one of the following values:

               [4mdefault[0m
                   default host policy

               [4mpreferred[0m
                   prefer the given host node list for allocation

               [4mbind[0m
                   restrict memory allocation to the given host node list

               [4minterleave[0m
                   interleave memory allocations across the given host node list

               The [1malign [22moption specifies the base address alignment when QEMU [1mmmap[22m(2) [1mmem-path[22m, and accepts common suffixes, eg [1m2M[22m. Some backend store specified by [1mmem-path [22mrequires an alignment different than the default one used
               by QEMU, eg the device DAX /dev/dax0.0 requires 2M alignment rather than 4K. In such cases, users can specify the required alignment via this option.

               The [1mpmem [22moption specifies whether the backing file specified by [1mmem-path [22mis in host persistent memory that can be accessed using the SNIA NVM programming model (e.g. Intel NVDIMM).  If [1mpmem [22mis set to 'on', QEMU will
               take necessary operations to guarantee the persistence of its own writes to [1mmem-path [22m(e.g. in vNVDIMM label emulation and live migration).

           [1m-object memory-backend-ram,id=[4m[22mid[24m[1m,merge=[4m[22mon|off[24m[1m,dump=[4m[22mon|off[24m[1m,share=[4m[22mon|off[24m[1m,prealloc=[4m[22mon|off[24m[1m,size=[4m[22msize[24m[1m,host-nodes=[4m[22mhost-nodes[24m[1m,policy=[4m[22mdefault|preferred|bind|interleave[0m
               Creates a memory backend object, which can be used to back the guest RAM.  Memory backend objects offer more control than the [1m-m [22moption that is traditionally used to define guest RAM. Please refer to [1mmemory-backend-[0m
               [1mfile [22mfor a description of the options.

           [1m-object memory-backend-memfd,id=[4m[22mid[24m[1m,merge=[4m[22mon|off[24m[1m,dump=[4m[22mon|off[24m[1m,share=[4m[22mon|off[24m[1m,prealloc=[4m[22mon|off[24m[1m,size=[4m[22msize[24m[1m,host-nodes=[4m[22mhost-nodes[24m[1m,policy=[4m[22mdefault|preferred|bind|interleave[24m[1m,seal=[4m[22mon|off[24m[1m,hugetlb=[4m[22mon|off[24m[1m,hugetlbsize=[4m[22msize[0m
               Creates an anonymous memory file backend object, which allows QEMU to share the memory with an external process (e.g. when using vhost-user). The memory is allocated with memfd and optional sealing. (Linux only)

               The [1mseal [22moption creates a sealed-file, that will block further resizing the memory ('on' by default).

               The [1mhugetlb [22moption specify the file to be created resides in the hugetlbfs filesystem (since Linux 4.14).  Used in conjunction with the [1mhugetlb [22moption, the [1mhugetlbsize [22moption specify the hugetlb page size on systems
               that support multiple hugetlb page sizes (it must be a power of 2 value supported by the system).

               In some versions of Linux, the [1mhugetlb [22moption is incompatible with the [1mseal [22moption (requires at least Linux 4.16).

               Please refer to [1mmemory-backend-file [22mfor a description of the other options.

               The [1mshare [22mboolean option is [4mon[24m by default with memfd.

           [1m-object rng-random,id=[4m[22mid[24m[1m,filename=[4m[22m/dev/random[0m
               Creates a random number generator backend which obtains entropy from a device on the host. The [1mid [22mparameter is a unique ID that will be used to reference this entropy backend from the [1mvirtio-rng [22mdevice. The [1mfilename[0m
               parameter specifies which file to obtain entropy from and if omitted defaults to [1m/dev/random[22m.

           [1m-object rng-egd,id=[4m[22mid[24m[1m,chardev=[4m[22mchardevid[0m
               Creates a random number generator backend which obtains entropy from an external daemon running on the host. The [1mid [22mparameter is a unique ID that will be used to reference this entropy backend from the [1mvirtio-rng[0m
               device. The [1mchardev [22mparameter is the unique ID of a character device backend that provides the connection to the RNG daemon.

           [1m-object tls-creds-anon,id=[4m[22mid[24m[1m,endpoint=[4m[22mendpoint[24m[1m,dir=[4m[22m/path/to/cred/dir[24m[1m,verify-peer=[4m[22mon|off[0m
               Creates a TLS anonymous credentials object, which can be used to provide TLS support on network backends. The [1mid [22mparameter is a unique ID which network backends will use to access the credentials. The [1mendpoint [22mis
               either [1mserver [22mor [1mclient [22mdepending on whether the QEMU network backend that uses the credentials will be acting as a client or as a server. If [1mverify-peer [22mis enabled (the default) then once the handshake is completed,
               the peer credentials will be verified, though this is a no-op for anonymous credentials.

               The [4mdir[24m parameter tells QEMU where to find the credential files. For server endpoints, this directory may contain a file [4mdh-params.pem[24m providing diffie-hellman parameters to use for the TLS server. If the file is
               missing, QEMU will generate a set of DH parameters at startup. This is a computationally expensive operation that consumes random pool entropy, so it is recommended that a persistent set of parameters be generated
               upfront and saved.

           [1m-object tls-creds-psk,id=[4m[22mid[24m[1m,endpoint=[4m[22mendpoint[24m[1m,dir=[4m[22m/path/to/keys/dir[24m[1m[,username=[4m[22musername[24m[1m][0m
               Creates a TLS Pre-Shared Keys (PSK) credentials object, which can be used to provide TLS support on network backends. The [1mid [22mparameter is a unique ID which network backends will use to access the credentials. The
               [1mendpoint [22mis either [1mserver [22mor [1mclient [22mdepending on whether the QEMU network backend that uses the credentials will be acting as a client or as a server. For clients only, [1musername [22mis the username which will be sent to
               the server.  If omitted it defaults to "qemu".

               The [4mdir[24m parameter tells QEMU where to find the keys file.  It is called "[4mdir[24m/keys.psk" and contains "username:key" pairs.  This file can most easily be created using the GnuTLS "psktool" program.

               For server endpoints, [4mdir[24m may also contain a file [4mdh-params.pem[24m providing diffie-hellman parameters to use for the TLS server. If the file is missing, QEMU will generate a set of DH parameters at startup. This is a
               computationally expensive operation that consumes random pool entropy, so it is recommended that a persistent set of parameters be generated up front and saved.

           [1m-object tls-creds-x509,id=[4m[22mid[24m[1m,endpoint=[4m[22mendpoint[24m[1m,dir=[4m[22m/path/to/cred/dir[24m[1m,priority=[4m[22mpriority[24m[1m,verify-peer=[4m[22mon|off[24m[1m,passwordid=[4m[22mid[0m
               Creates a TLS anonymous credentials object, which can be used to provide TLS support on network backends. The [1mid [22mparameter is a unique ID which network backends will use to access the credentials. The [1mendpoint [22mis
               either [1mserver [22mor [1mclient [22mdepending on whether the QEMU network backend that uses the credentials will be acting as a client or as a server. If [1mverify-peer [22mis enabled (the default) then once the handshake is completed,
               the peer credentials will be verified. With x509 certificates, this implies that the clients must be provided with valid client certificates too.

               The [4mdir[24m parameter tells QEMU where to find the credential files. For server endpoints, this directory may contain a file [4mdh-params.pem[24m providing diffie-hellman parameters to use for the TLS server. If the file is
               missing, QEMU will generate a set of DH parameters at startup. This is a computationally expensive operation that consumes random pool entropy, so it is recommended that a persistent set of parameters be generated
               upfront and saved.

               For x509 certificate credentials the directory will contain further files providing the x509 certificates. The certificates must be stored in PEM format, in filenames [4mca-cert.pem[24m, [4mca-crl.pem[24m (optional),
               [4mserver-cert.pem[24m (only servers), [4mserver-key.pem[24m (only servers), [4mclient-cert.pem[24m (only clients), and [4mclient-key.pem[24m (only clients).

               For the [4mserver-key.pem[24m and [4mclient-key.pem[24m files which contain sensitive private keys, it is possible to use an encrypted version by providing the [4mpasswordid[24m parameter. This provides the ID of a previously created
               "secret" object containing the password for decryption.

               The [4mpriority[24m parameter allows to override the global default priority used by gnutls. This can be useful if the system administrator needs to use a weaker set of crypto priorities for QEMU without potentially forcing
               the weakness onto all applications. Or conversely if one wants wants a stronger default for QEMU than for all other applications, they can do this through this parameter. Its format is a gnutls priority string as
               described at <[1mhttps://gnutls.org/manual/html_node/Priority-Strings.html[22m>.

           [1m-object filter-buffer,id=[4m[22mid[24m[1m,netdev=[4m[22mnetdevid[24m[1m,interval=[4m[22mt[24m[1m[,queue=[4m[22mall|rx|tx[24m[1m][,status=[4m[22mon|off[24m[1m][0m
               Interval [4mt[24m can't be 0, this filter batches the packet delivery: all packets arriving in a given interval on netdev [4mnetdevid[24m are delayed until the end of the interval. Interval is in microseconds.  [1mstatus [22mis optional
               that indicate whether the netfilter is on (enabled) or off (disabled), the default status for netfilter will be 'on'.

               queue [4mall|rx|tx[24m is an option that can be applied to any netfilter.

               [1mall[22m: the filter is attached both to the receive and the transmit queue of the netdev (default).

               [1mrx[22m: the filter is attached to the receive queue of the netdev, where it will receive packets sent to the netdev.

               [1mtx[22m: the filter is attached to the transmit queue of the netdev, where it will receive packets sent by the netdev.

           [1m-object filter-mirror,id=[4m[22mid[24m[1m,netdev=[4m[22mnetdevid[24m[1m,outdev=[4m[22mchardevid[24m[1m,queue=[4m[22mall|rx|tx[24m[1m[,vnet_hdr_support][0m
               filter-mirror on netdev [4mnetdevid[24m,mirror net packet to chardev[4mchardevid[24m, if it has the vnet_hdr_support flag, filter-mirror will mirror packet with vnet_hdr_len.

           [1m-object filter-redirector,id=[4m[22mid[24m[1m,netdev=[4m[22mnetdevid[24m[1m,indev=[4m[22mchardevid[24m[1m,outdev=[4m[22mchardevid[24m[1m,queue=[4m[22mall|rx|tx[24m[1m[,vnet_hdr_support][0m
               filter-redirector on netdev [4mnetdevid[24m,redirect filter's net packet to chardev [4mchardevid[24m,and redirect indev's packet to filter.if it has the vnet_hdr_support flag, filter-redirector will redirect packet with
               vnet_hdr_len.  Create a filter-redirector we need to differ outdev id from indev id, id can not be the same. we can just use indev or outdev, but at least one of indev or outdev need to be specified.

           [1m-object filter-rewriter,id=[4m[22mid[24m[1m,netdev=[4m[22mnetdevid[24m[1m,queue=[4m[22mall|rx|tx[24m[1m,[vnet_hdr_support][0m
               Filter-rewriter is a part of COLO project.It will rewrite tcp packet to secondary from primary to keep secondary tcp connection,and rewrite tcp packet to primary from secondary make tcp packet can be handled by
               client.if it has the vnet_hdr_support flag, we can parse packet with vnet header.

               usage: colo secondary: -object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 -object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1 -object filter-rewriter,id=rew0,netdev=hn0,queue=all

           [1m-object filter-dump,id=[4m[22mid[24m[1m,netdev=[4m[22mdev[24m[1m[,file=[4m[22mfilename[24m[1m][,maxlen=[4m[22mlen[24m[1m][0m
               Dump the network traffic on netdev [4mdev[24m to the file specified by [4mfilename[24m. At most [4mlen[24m bytes (64k by default) per packet are stored.  The file format is libpcap, so it can be analyzed with tools such as tcpdump or
               Wireshark.

           [1m-object colo-compare,id=[4m[22mid[24m[1m,primary_in=[4m[22mchardevid[24m[1m,secondary_in=[4m[22mchardevid[24m[1m,outdev=[4m[22mchardevid[24m[1m[,vnet_hdr_support][0m
               Colo-compare gets packet from primary_in[4mchardevid[24m and secondary_in[4mchardevid[24m, than compare primary packet with secondary packet. If the packets are same, we will output primary packet to outdev[4mchardevid[24m, else we will
               notify colo-frame do checkpoint and send primary packet to outdev[4mchardevid[24m.  if it has the vnet_hdr_support flag, colo compare will send/recv packet with vnet_hdr_len.

               we must use it with the help of filter-mirror and filter-redirector.

                       primary:
                       -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown
                       -device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66
                       -chardev socket,id=mirror0,host=3.3.3.3,port=9003,server,nowait
                       -chardev socket,id=compare1,host=3.3.3.3,port=9004,server,nowait
                       -chardev socket,id=compare0,host=3.3.3.3,port=9001,server,nowait
                       -chardev socket,id=compare0-0,host=3.3.3.3,port=9001
                       -chardev socket,id=compare_out,host=3.3.3.3,port=9005,server,nowait
                       -chardev socket,id=compare_out0,host=3.3.3.3,port=9005
                       -object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0
                       -object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out
                       -object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0
                       -object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0

                       secondary:
                       -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown
                       -device e1000,netdev=hn0,mac=52:a4:00:12:78:66
                       -chardev socket,id=red0,host=3.3.3.3,port=9003
                       -chardev socket,id=red1,host=3.3.3.3,port=9004
                       -object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0
                       -object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1

               If you want to know the detail of above command line, you can read the colo-compare git log.

           [1m-object cryptodev-backend-builtin,id=[4m[22mid[24m[1m[,queues=[4m[22mqueues[24m[1m][0m
               Creates a cryptodev backend which executes crypto opreation from the QEMU cipher APIS. The [4mid[24m parameter is a unique ID that will be used to reference this cryptodev backend from the [1mvirtio-crypto [22mdevice. The [4mqueues[0m
               parameter is optional, which specify the queue number of cryptodev backend, the default of [4mqueues[24m is 1.

                       # qemu-system-x86_64 \
                       [...] \
                       -object cryptodev-backend-builtin,id=cryptodev0 \
                       -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
                       [...]

           [1m-object cryptodev-vhost-user,id=[4m[22mid[24m[1m,chardev=[4m[22mchardevid[24m[1m[,queues=[4m[22mqueues[24m[1m][0m
               Creates a vhost-user cryptodev backend, backed by a chardev [4mchardevid[24m.  The [4mid[24m parameter is a unique ID that will be used to reference this cryptodev backend from the [1mvirtio-crypto [22mdevice.  The chardev should be a
               unix domain socket backed one. The vhost-user uses a specifically defined protocol to pass vhost ioctl replacement messages to an application on the other end of the socket.  The [4mqueues[24m parameter is optional, which
               specify the queue number of cryptodev backend for multiqueue vhost-user, the default of [4mqueues[24m is 1.

                       # qemu-system-x86_64 \
                       [...] \
                       -chardev socket,id=chardev0,path=/path/to/socket \
                       -object cryptodev-vhost-user,id=cryptodev0,chardev=chardev0 \
                       -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \
                       [...]

           [1m-object secret,id=[4m[22mid[24m[1m,data=[4m[22mstring[24m[1m,format=[4m[22mraw|base64[24m[1m[,keyid=[4m[22msecretid[24m[1m,iv=[4m[22mstring[24m[1m][0m
           [1m-object secret,id=[4m[22mid[24m[1m,file=[4m[22mfilename[24m[1m,format=[4m[22mraw|base64[24m[1m[,keyid=[4m[22msecretid[24m[1m,iv=[4m[22mstring[24m[1m][0m
               Defines a secret to store a password, encryption key, or some other sensitive data. The sensitive data can either be passed directly via the [4mdata[24m parameter, or indirectly via the [4mfile[24m parameter. Using the [4mdata[0m
               parameter is insecure unless the sensitive data is encrypted.

               The sensitive data can be provided in raw format (the default), or base64.  When encoded as JSON, the raw format only supports valid UTF-8 characters, so base64 is recommended for sending binary data. QEMU will
               convert from which ever format is provided to the format it needs internally. eg, an RBD password can be provided in raw format, even though it will be base64 encoded when passed onto the RBD sever.

               For added protection, it is possible to encrypt the data associated with a secret using the AES-256-CBC cipher. Use of encryption is indicated by providing the [4mkeyid[24m and [4miv[24m parameters. The [4mkeyid[24m parameter provides
               the ID of a previously defined secret that contains the AES-256 decryption key. This key should be 32-bytes long and be base64 encoded. The [4miv[24m parameter provides the random initialization vector used for encryption
               of this particular secret and should be a base64 encrypted string of the 16-byte IV.

               The simplest (insecure) usage is to provide the secret inline

                       # $QEMU -object secret,id=sec0,data=letmein,format=raw

               The simplest secure usage is to provide the secret via a file

               # printf "letmein" > mypasswd.txt # $QEMU -object secret,id=sec0,file=mypasswd.txt,format=raw

               For greater security, AES-256-CBC should be used. To illustrate usage, consider the openssl command line tool which can encrypt the data. Note that when encrypting, the plaintext must be padded to the cipher block
               size (32 bytes) using the standard PKCS#5/6 compatible padding algorithm.

               First a master key needs to be created in base64 encoding:

                       # openssl rand -base64 32 > key.b64
                       # KEY=$(base64 -d key.b64 | hexdump  -v -e '/1 "%02X"')

               Each secret to be encrypted needs to have a random initialization vector generated. These do not need to be kept secret

                       # openssl rand -base64 16 > iv.b64
                       # IV=$(base64 -d iv.b64 | hexdump  -v -e '/1 "%02X"')

               The secret to be defined can now be encrypted, in this case we're telling openssl to base64 encode the result, but it could be left as raw bytes if desired.

                       # SECRET=$(printf "letmein" |
                       openssl enc -aes-256-cbc -a -K $KEY -iv $IV)

               When launching QEMU, create a master secret pointing to "key.b64" and specify that to be used to decrypt the user password. Pass the contents of "iv.b64" to the second secret

                       # $QEMU \
                       -object secret,id=secmaster0,format=base64,file=key.b64 \
                       -object secret,id=sec0,keyid=secmaster0,format=base64,\
                       data=$SECRET,iv=$(<iv.b64)

           [1m-object sev-guest,id=[4m[22mid[24m[1m,cbitpos=[4m[22mcbitpos[24m[1m,reduced-phys-bits=[4m[22mval[24m[1m,[sev-device=[4m[22mstring[24m[1m,policy=[4m[22mpolicy[24m[1m,handle=[4m[22mhandle[24m[1m,dh-cert-file=[4m[22mfile[24m[1m,session-file=[4m[22mfile[24m[1m][0m
               Create a Secure Encrypted Virtualization (SEV) guest object, which can be used to provide the guest memory encryption support on AMD processors.

               When memory encryption is enabled, one of the physical address bit (aka the C-bit) is utilized to mark if a memory page is protected. The [1mcbitpos [22mis used to provide the C-bit position. The C-bit position is Host
               family dependent hence user must provide this value. On EPYC, the value should be 47.

               When memory encryption is enabled, we loose certain bits in physical address space.  The [1mreduced-phys-bits [22mis used to provide the number of bits we loose in physical address space. Similar to C-bit, the value is Host
               family dependent.  On EPYC, the value should be 5.

               The [1msev-device [22mprovides the device file to use for communicating with the SEV firmware running inside AMD Secure Processor. The default device is '/dev/sev'. If hardware supports memory encryption then /dev/sev
               devices are created by CCP driver.

               The [1mpolicy [22mprovides the guest policy to be enforced by the SEV firmware and restrict what configuration and operational commands can be performed on this guest by the hypervisor. The policy should be provided by the
               guest owner and is bound to the guest and cannot be changed throughout the lifetime of the guest.  The default is 0.

               If guest [1mpolicy [22mallows sharing the key with another SEV guest then [1mhandle [22mcan be use to provide handle of the guest from which to share the key.

               The [1mdh-cert-file [22mand [1msession-file [22mprovides the guest owner's Public Diffie-Hillman key defined in SEV spec. The PDH and session parameters are used for establishing a cryptographic session with the guest owner to
               negotiate keys used for attestation. The file must be encoded in base64.

               e.g to launch a SEV guest

                       # $QEMU \
                       ......
                       -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=5 \
                       -machine ...,memory-encryption=sev0
                       .....

       During the graphical emulation, you can use special key combinations to change modes. The default key mappings are shown below, but if you use "-alt-grab" then the modifier is Ctrl-Alt-Shift (instead of Ctrl-Alt) and if you
       use "-ctrl-grab" then the modifier is the right Ctrl key (instead of Ctrl-Alt):

       [1mCtrl-Alt-f[0m
           Toggle full screen

       [1mCtrl-Alt-+[0m
           Enlarge the screen

       [1mCtrl-Alt--[0m
           Shrink the screen

       [1mCtrl-Alt-u[0m
           Restore the screen's un-scaled dimensions

       [1mCtrl-Alt-n[0m
           Switch to virtual console 'n'. Standard console mappings are:

           [4m1[24m   Target system display

           [4m2[24m   Monitor

           [4m3[24m   Serial port

       [1mCtrl-Alt[0m
           Toggle mouse and keyboard grab.

       In the virtual consoles, you can use [1mCtrl-Up[22m, [1mCtrl-Down[22m, [1mCtrl-PageUp [22mand [1mCtrl-PageDown [22mto move in the back log.

       During emulation, if you are using a character backend multiplexer (which is the default if you are using [1m-nographic[22m) then several commands are available via an escape sequence. These key sequences all start with an escape
       character, which is [1mCtrl-a [22mby default, but can be changed with [1m-echr[22m. The list below assumes you're using the default.

       [1mCtrl-a h[0m
           Print this help

       [1mCtrl-a x[0m
           Exit emulator

       [1mCtrl-a s[0m
           Save disk data back to file (if -snapshot)

       [1mCtrl-a t[0m
           Toggle console timestamps

       [1mCtrl-a b[0m
           Send break (magic sysrq in Linux)

       [1mCtrl-a c[0m
           Rotate between the frontends connected to the multiplexer (usually this switches between the monitor and the console)

       [1mCtrl-a Ctrl-a[0m
           Send the escape character to the frontend

       The following options are specific to the PowerPC emulation:

       [1m-g [4m[22mW[24m[1mx[4m[22mH[24m[1m[x[4m[22mDEPTH[24m[1m][0m
           Set the initial VGA graphic mode. The default is 800x600x32.

       [1m-prom-env [4m[22mstring[0m
           Set OpenBIOS variables in NVRAM, for example:

                   qemu-system-ppc -prom-env 'auto-boot?=false' \
                    -prom-env 'boot-device=hd:2,\yaboot' \
                    -prom-env 'boot-args=conf=hd:2,\yaboot.conf'

           These variables are not used by Open Hack'Ware.

       The following options are specific to the Sparc32 emulation:

       [1m-g [4m[22mW[24m[1mx[4m[22mH[24m[1mx[x[4m[22mDEPTH[24m[1m][0m
           Set the initial graphics mode. For TCX, the default is 1024x768x8 with the option of 1024x768x24. For cgthree, the default is 1024x768x8 with the option of 1152x900x8 for people who wish to use OBP.

       [1m-prom-env [4m[22mstring[0m
           Set OpenBIOS variables in NVRAM, for example:

                   qemu-system-sparc -prom-env 'auto-boot?=false' \
                    -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'

       [1m-M [SS-4|SS-5|SS-10|SS-20|SS-600MP|LX|Voyager|SPARCClassic] [|SPARCbook][0m
           Set the emulated machine type. Default is SS-5.

       The following options are specific to the Sparc64 emulation:

       [1m-prom-env [4m[22mstring[0m
           Set OpenBIOS variables in NVRAM, for example:

                   qemu-system-sparc64 -prom-env 'auto-boot?=false'

       [1m-M [sun4u|sun4v|niagara][0m
           Set the emulated machine type. The default is sun4u.

       The following options are specific to the ARM emulation:

       [1m-semihosting[0m
           Enable semihosting syscall emulation.

           On ARM this implements the "Angel" interface.

           Note that this allows guest direct access to the host filesystem, so should only be used with trusted guest OS.

       The following options are specific to the ColdFire emulation:

       [1m-semihosting[0m
           Enable semihosting syscall emulation.

           On M68K this implements the "ColdFire GDB" interface used by libgloss.

           Note that this allows guest direct access to the host filesystem, so should only be used with trusted guest OS.

       The following options are specific to the Xtensa emulation:

       [1m-semihosting[0m
           Enable semihosting syscall emulation.

           Xtensa semihosting provides basic file IO calls, such as open/read/write/seek/select.  Tensilica baremetal libc for ISS and linux platform "sim" use this interface.

           Note that this allows guest direct access to the host filesystem, so should only be used with trusted guest OS.

[1mNOTES[0m
       In addition to using normal file images for the emulated storage devices, QEMU can also use networked resources such as iSCSI devices. These are specified using a special URL syntax.

       [1miSCSI[0m
           iSCSI support allows QEMU to access iSCSI resources directly and use as images for the guest storage. Both disk and cdrom images are supported.

           Syntax for specifying iSCSI LUNs is "iscsi://<target-ip>[:<port>]/<target-iqn>/<lun>"

           By default qemu will use the iSCSI initiator-name 'iqn.2008-11.org.linux-kvm[:<name>]' but this can also be set from the command line or a configuration file.

           Since version Qemu 2.4 it is possible to specify a iSCSI request timeout to detect stalled requests and force a reestablishment of the session. The timeout is specified in seconds. The default is 0 which means no
           timeout. Libiscsi 1.15.0 or greater is required for this feature.

           Example (without authentication):

                   qemu-system-i386 -iscsi initiator-name=iqn.2001-04.com.example:my-initiator \
                                    -cdrom iscsi://192.0.2.1/iqn.2001-04.com.example/2 \
                                    -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1

           Example (CHAP username/password via URL):

                   qemu-system-i386 -drive file=iscsi://user%password@192.0.2.1/iqn.2001-04.com.example/1

           Example (CHAP username/password via environment variables):

                   LIBISCSI_CHAP_USERNAME="user" \
                   LIBISCSI_CHAP_PASSWORD="password" \
                   qemu-system-i386 -drive file=iscsi://192.0.2.1/iqn.2001-04.com.example/1

       [1mNBD [22mQEMU supports NBD (Network Block Devices) both using TCP protocol as well as Unix Domain Sockets.

           Syntax for specifying a NBD device using TCP "nbd:<server-ip>:<port>[:exportname=<export>]"

           Syntax for specifying a NBD device using Unix Domain Sockets "nbd:unix:<domain-socket>[:exportname=<export>]"

           Example for TCP

                   qemu-system-i386 --drive file=nbd:192.0.2.1:30000

           Example for Unix Domain Sockets

                   qemu-system-i386 --drive file=nbd:unix:/tmp/nbd-socket

       [1mSSH [22mQEMU supports SSH (Secure Shell) access to remote disks.

           Examples:

                   qemu-system-i386 -drive file=ssh://user@host/path/to/disk.img
                   qemu-system-i386 -drive file.driver=ssh,file.user=user,file.host=host,file.port=22,file.path=/path/to/disk.img

           Currently authentication must be done using ssh-agent.  Other authentication methods may be supported in future.

       [1mSheepdog[0m
           Sheepdog is a distributed storage system for QEMU.  QEMU supports using either local sheepdog devices or remote networked devices.

           Syntax for specifying a sheepdog device

                   sheepdog[+tcp|+unix]://[host:port]/vdiname[?socket=path][#snapid|#tag]

           Example

                   qemu-system-i386 --drive file=sheepdog://192.0.2.1:30000/MyVirtualMachine

           See also <[1mhttps://sheepdog.github.io/sheepdog/[22m>.

       [1mGlusterFS[0m
           GlusterFS is a user space distributed file system.  QEMU supports the use of GlusterFS volumes for hosting VM disk images using TCP, Unix Domain Sockets and RDMA transport protocols.

           Syntax for specifying a VM disk image on GlusterFS volume is

                   URI:
                   gluster[+type]://[host[:port]]/volume/path[?socket=...][,debug=N][,logfile=...]

                   JSON:
                   'json:{"driver":"qcow2","file":{"driver":"gluster","volume":"testvol","path":"a.img","debug":N,"logfile":"...",
                                                    "server":[{"type":"tcp","host":"...","port":"..."},
                                                              {"type":"unix","socket":"..."}]}}'

           Example

                   URI:
                   qemu-system-x86_64 --drive file=gluster://192.0.2.1/testvol/a.img,
                                                  file.debug=9,file.logfile=/var/log/qemu-gluster.log

                   JSON:
                   qemu-system-x86_64 'json:{"driver":"qcow2",
                                             "file":{"driver":"gluster",
                                                      "volume":"testvol","path":"a.img",
                                                      "debug":9,"logfile":"/var/log/qemu-gluster.log",
                                                      "server":[{"type":"tcp","host":"1.2.3.4","port":24007},
                                                                {"type":"unix","socket":"/var/run/glusterd.socket"}]}}'
                   qemu-system-x86_64 -drive driver=qcow2,file.driver=gluster,file.volume=testvol,file.path=/path/a.img,
                                                         file.debug=9,file.logfile=/var/log/qemu-gluster.log,
                                                         file.server.0.type=tcp,file.server.0.host=1.2.3.4,file.server.0.port=24007,
                                                         file.server.1.type=unix,file.server.1.socket=/var/run/glusterd.socket

           See also <[1mhttp://www.gluster.org[22m>.

       [1mHTTP/HTTPS/FTP/FTPS[0m
           QEMU supports read-only access to files accessed over http(s) and ftp(s).

           Syntax using a single filename:

                   <protocol>://[<username>[:<password>]@]<host>/<path>

           where:

           [1mprotocol[0m
               'http', 'https', 'ftp', or 'ftps'.

           [1musername[0m
               Optional username for authentication to the remote server.

           [1mpassword[0m
               Optional password for authentication to the remote server.

           [1mhost[0m
               Address of the remote server.

           [1mpath[0m
               Path on the remote server, including any query string.

           The following options are also supported:

           [1murl [22mThe full URL when passing options to the driver explicitly.

           [1mreadahead[0m
               The amount of data to read ahead with each range request to the remote server.  This value may optionally have the suffix 'T', 'G', 'M', 'K', 'k' or 'b'. If it does not have a suffix, it will be assumed to be in
               bytes. The value must be a multiple of 512 bytes. It defaults to 256k.

           [1msslverify[0m
               Whether to verify the remote server's certificate when connecting over SSL. It can have the value 'on' or 'off'. It defaults to 'on'.

           [1mcookie[0m
               Send this cookie (it can also be a list of cookies separated by ';') with each outgoing request.  Only supported when using protocols such as HTTP which support cookies, otherwise ignored.

           [1mtimeout[0m
               Set the timeout in seconds of the CURL connection. This timeout is the time that CURL waits for a response from the remote server to get the size of the image to be downloaded. If not set, the default timeout of 5
               seconds is used.

           Note that when passing options to qemu explicitly, [1mdriver [22mis the value of <protocol>.

           Example: boot from a remote Fedora 20 live ISO image

                   qemu-system-x86_64 --drive media=cdrom,file=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly

                   qemu-system-x86_64 --drive media=cdrom,file.driver=http,file.url=http://dl.fedoraproject.org/pub/fedora/linux/releases/20/Live/x86_64/Fedora-Live-Desktop-x86_64-20-1.iso,readonly

           Example: boot from a remote Fedora 20 cloud image using a local overlay for writes, copy-on-read, and a readahead of 64k

                   qemu-img create -f qcow2 -o backing_file='json:{"file.driver":"http",, "file.url":"https://dl.fedoraproject.org/pub/fedora/linux/releases/20/Images/x86_64/Fedora-x86_64-20-20131211.1-sda.qcow2",, "file.readahead":"64k"}' /tmp/Fedora-x86_64-20-20131211.1-sda.qcow2

                   qemu-system-x86_64 -drive file=/tmp/Fedora-x86_64-20-20131211.1-sda.qcow2,copy-on-read=on

           Example: boot from an image stored on a VMware vSphere server with a self-signed certificate using a local overlay for writes, a readahead of 64k and a timeout of 10 seconds.

                   qemu-img create -f qcow2 -o backing_file='json:{"file.driver":"https",, "file.url":"https://user:password@vsphere.example.com/folder/test/test-flat.vmdk?dcPath=Datacenter&dsName=datastore1",, "file.sslverify":"off",, "file.readahead":"64k",, "file.timeout":10}' /tmp/test.qcow2

                   qemu-system-x86_64 -drive file=/tmp/test.qcow2

[1mSEE ALSO[0m
       The HTML documentation of QEMU for more precise information and Linux user mode emulator invocation.

[1mAUTHOR[0m
       Fabrice Bellard

                                                                                                               2019-08-14                                                                                                     QEMU.1(1)
